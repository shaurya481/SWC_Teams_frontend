{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"children\", \"className\", \"maxVisible\", \"noTrailingSlash\", \"overflowAriaLabel\"];\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n} //\n// Copyright IBM Corp. 2020, 2020\n//\n// This source code is licensed under the Apache-2.0 license found in the\n// LICENSE file in the root directory of this source tree.\n//\n// Import portions of React that are needed.\n\n\nimport React, { useState, useEffect, useRef } from 'react'; // Other standard imports.\n\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { Button } from 'carbon-components-react';\nimport { pkg, carbon } from '../../settings';\nimport ReactResizeDetector from 'react-resize-detector';\nimport { ArrowLeft16 } from '@carbon/icons-react'; // Carbon and package components we use.\n\nimport { Breadcrumb, BreadcrumbItem, OverflowMenu, OverflowMenuItem } from 'carbon-components-react';\nimport { OverflowMenuHorizontal32 } from '@carbon/icons-react';\nimport uuidv4 from '../../global/js/utils/uuidv4';\nimport unwrapIfFragment from '../../global/js/utils/unwrap-if-fragment'; // The block part of our conventional BEM class names (blockClass__E--M).\n\nvar blockClass = \"\".concat(pkg.prefix, \"--breadcrumb-with-overflow\");\nvar componentName = 'BreadcrumbWithOverflow'; // NOTE: the component SCSS is not imported here: it is rolled up separately.\n\n/**\n * The BreadcrumbWithOverflow is used internally by the PageHeader to wrap BreadcrumbItems.\n */\n\nexport var BreadcrumbWithOverflow = function BreadcrumbWithOverflow(_ref) {\n  var _backItem, _backItem$props;\n\n  var children = _ref.children,\n      className = _ref.className,\n      maxVisible = _ref.maxVisible,\n      noTrailingSlash = _ref.noTrailingSlash,\n      overflowAriaLabel = _ref.overflowAriaLabel,\n      other = _objectWithoutProperties(_ref, _excluded);\n\n  var _useState = useState(3),\n      _useState2 = _slicedToArray(_useState, 2),\n      displayCount = _useState2[0],\n      setDisplayCount = _useState2[1];\n\n  var _useState3 = useState([]),\n      _useState4 = _slicedToArray(_useState3, 2),\n      displayedBreadcrumbItems = _useState4[0],\n      setDisplayedBreadcrumbItems = _useState4[1];\n\n  var breadcrumbItemWithOverflow = useRef(null);\n  var sizingContainerRef = useRef(null);\n  var internalId = useRef(uuidv4());\n\n  var _useState5 = useState([]),\n      _useState6 = _slicedToArray(_useState5, 2),\n      childArray = _useState6[0],\n      setChildArray = _useState6[1];\n\n  var getHref = function getHref(item) {\n    var _item$props, _item$props2, _item$props2$children, _item$props2$children2; // This function should extract href from item\n    // It expects that the href is attached either to the item or direct child\n    // It prefers item.props.href\n\n\n    return item !== null && item !== void 0 && (_item$props = item.props) !== null && _item$props !== void 0 && _item$props.href ? item.props.href : item === null || item === void 0 ? void 0 : (_item$props2 = item.props) === null || _item$props2 === void 0 ? void 0 : (_item$props2$children = _item$props2.children) === null || _item$props2$children === void 0 ? void 0 : (_item$props2$children2 = _item$props2$children.props) === null || _item$props2$children2 === void 0 ? void 0 : _item$props2$children2.href;\n  };\n\n  var getTitle = function getTitle(item) {\n    // This function should extract text based title from the item.\n    // It prefers in this order\n    // - item.props.data-title\n    // - item.props.title\n    // - item.props.children if string\n    // - item.props.children.props.children if string. This case is likely if an <a /> is used inside a BreadcrumbItem\n    var useAsTitle = null;\n\n    if (item !== null && item !== void 0 && item.props) {\n      var _item$props3, _item$props3$children, _item$props3$children2;\n\n      if (item.props['data-title']) {\n        useAsTitle = item.props['data-title'];\n      } else if (item.props.title) {\n        useAsTitle = item.props.title;\n      } else if (typeof item.props.children === 'string') {\n        useAsTitle = item.props.children;\n      } else if (typeof ((_item$props3 = item.props) === null || _item$props3 === void 0 ? void 0 : (_item$props3$children = _item$props3.children) === null || _item$props3$children === void 0 ? void 0 : (_item$props3$children2 = _item$props3$children.props) === null || _item$props3$children2 === void 0 ? void 0 : _item$props3$children2.children) === 'string') {\n        useAsTitle = item.props.children.props.children;\n      }\n    }\n\n    return useAsTitle;\n  }; // eslint-disable-next-line react/prop-types\n\n\n  var BreadcrumbOverflowMenu = function BreadcrumbOverflowMenu(_ref2) {\n    var overflowItems = _ref2.overflowItems;\n    return /*#__PURE__*/React.createElement(BreadcrumbItem, {\n      key: \"breadcrumb-overflow-\".concat(internalId.current)\n    }, /*#__PURE__*/React.createElement(OverflowMenu, {\n      ariaLabel: null,\n      menuOffset: {\n        top: 10,\n        left: 59\n      } // TODO: REMOVE borrowed from https://github.com/carbon-design-system/carbon/pull/7085\n      ,\n      renderIcon: OverflowMenuHorizontal32,\n      className: \"\".concat(blockClass, \"__overflow-menu\"),\n      menuOptionsClass: \"\".concat(carbon.prefix, \"--breadcrumb-menu-options\") // TODO: REMOVE borrowed from https://github.com/carbon-design-system/carbon/pull/7085\n\n    }, // eslint-disable-next-line react/prop-types\n    overflowItems.map(function (item, index) {\n      return /*#__PURE__*/React.createElement(OverflowMenuItem, {\n        key: \"breadcrumb-overflow-menu-item-\".concat(internalId.current, \"-\").concat(index),\n        href: item.props.href,\n        onClick: item.props.onClick,\n        itemText: item.props.children\n      });\n    })));\n  }; // creates child array from children which may be a fragment\n\n\n  useEffect(function () {\n    setChildArray(unwrapIfFragment(children));\n  }, [children]);\n  useEffect(function () {\n    // updates displayedBreadcrumbItems and overflowBreadcrumbItems based on displayCount and childArray\n    if (childArray.length === 0) {\n      setDisplayedBreadcrumbItems([]);\n      return;\n    } // clones of children needed as the children are used in the sizing render\n\n\n    var cloneChildren = function cloneChildren(items) {\n      return items.map(function (item, index) {\n        // likely truncated add title\n        var title = index + 1 === childArray.length && displayCount === 1 ? getTitle(item) : null;\n        var className = index > 0 || displayCount > 1 ? cx([childArray[index].props.className, \"\".concat(blockClass, \"__displayed-breadcrumb\")]) : childArray[index].props.className;\n        return /*#__PURE__*/React.cloneElement(item, {\n          key: index,\n          title: title,\n          className: className\n        });\n      });\n    };\n\n    var newDisplayedBreadcrumbItems = cloneChildren(childArray); // The breadcrumb has the form [first item] [overflow] [items 2...(n-1)] [last item].\n    // The overflow is only shown if there isn't space to display all the items, and in that case:\n    //  * the last item is always displayed (even if there isn't really space for it -- it can contract to an ellipsis);\n    //  * the first item is the next to be displayed, if there's space once the last item and overflow are shown;\n    //  * any remaining space after the first item, last item and overflow are shown is used to show items (n-1), (n-2), (n-3), ..., until the space is used up ;\n    // Note that displayCount (min 1) has been computed based on the available space and the above sequence.\n\n    var overflowPosition = displayCount > 1 ? 1 : 0;\n    var newOverflowBreadcrumbItems = newDisplayedBreadcrumbItems.splice(overflowPosition, childArray.length - displayCount); // if needed add overflow menu\n\n    if (newOverflowBreadcrumbItems.length) {\n      newDisplayedBreadcrumbItems.splice(overflowPosition, 0, /*#__PURE__*/React.createElement(BreadcrumbOverflowMenu, {\n        overflowItems: newOverflowBreadcrumbItems,\n        key: \"$displayed-breadcrumb-\".concat(internalId, \"-overflow\")\n      }));\n    }\n\n    setDisplayedBreadcrumbItems(newDisplayedBreadcrumbItems);\n  }, [childArray, displayCount]);\n\n  var checkFullyVisibleBreadcrumbItems = function checkFullyVisibleBreadcrumbItems() {\n    var displayItemIndex = function displayItemIndex(itemCount, index) {\n      // In this data set the overflow measuring item is [0]\n      // so the first displayItem in the list is [1]\n      // we never return 0;\n      if (index === 0) {\n        return itemCount - 1; // the last item in the list\n      } else if (index === 1) {\n        return 1; // the first item in the list\n      } else {\n        return itemCount - index; // count down from itemCount - 2 to 1\n      }\n    };\n\n    if (maxVisible <= 1) {\n      setDisplayCount(1);\n    } else {\n      // how many will fit?\n      var willFit = 0;\n      var spaceAvailable = breadcrumbItemWithOverflow.current.offsetWidth; // not sure how to test resize\n\n      /* istanbul ignore next if */\n\n      if (sizingContainerRef.current) {\n        var sizingBreadcrumbItems = sizingContainerRef.current.querySelectorAll(\".\".concat(carbon.prefix, \"--breadcrumb-item\"));\n        var breadcrumbWidthsIncludingMargin = [];\n\n        var _iterator = _createForOfIteratorHelper(sizingBreadcrumbItems),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var item = _step.value;\n            var computedStyle = window ? window.getComputedStyle(sizingBreadcrumbItems[0]) : null;\n            var marginWidths = computedStyle ? parseFloat(computedStyle.marginLeft || 0, 10) + parseFloat(computedStyle.marginRight || 0, 10) : 0;\n            breadcrumbWidthsIncludingMargin.push(item.offsetWidth + marginWidths);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var overflowWidth = breadcrumbWidthsIncludingMargin[0];\n\n        for (var i = 0; i < breadcrumbWidthsIncludingMargin.length - 1; i++) {\n          // count used one less than length to account for the included overflow item\n          var index = displayItemIndex(breadcrumbWidthsIncludingMargin.length, i);\n\n          if (spaceAvailable >= breadcrumbWidthsIncludingMargin[index]) {\n            spaceAvailable -= breadcrumbWidthsIncludingMargin[index];\n            willFit += 1;\n          } else {\n            break;\n          }\n        } // if not enough space for all breadcrumb items\n\n\n        if (willFit < breadcrumbWidthsIncludingMargin.length - 1) {\n          // -1 for overflow item\n          while (willFit > 0 && spaceAvailable < overflowWidth) {\n            willFit -= 1; // Highly unlikely any useful breadcrumb-item is smaller than the overflow menu, but we loop anyway just in case\n            // item removed is based on last item added which is the current value of willFit\n\n            var itemToRemove = displayItemIndex(breadcrumbWidthsIncludingMargin.length, willFit);\n            spaceAvailable += breadcrumbWidthsIncludingMargin[itemToRemove];\n          }\n        }\n      }\n\n      if (willFit <= 1) {\n        setDisplayCount(1);\n      } else {\n        setDisplayCount(maxVisible ? Math.min(willFit, maxVisible) : willFit);\n      }\n    }\n  };\n\n  useEffect(function () {\n    checkFullyVisibleBreadcrumbItems(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [maxVisible]);\n\n  var handleResize = function handleResize() {\n    /* istanbul ignore next */\n    // not sure how to test resize\n    checkFullyVisibleBreadcrumbItems();\n  };\n\n  var handleBreadcrumbItemsResize = function handleBreadcrumbItemsResize() {\n    /* istanbul ignore next */\n    // not sure how to test resize\n    checkFullyVisibleBreadcrumbItems();\n  };\n\n  var backItem = childArray[childArray.length - 1];\n\n  if ((_backItem = backItem) !== null && _backItem !== void 0 && (_backItem$props = _backItem.props) !== null && _backItem$props !== void 0 && _backItem$props.isCurrentPage) {\n    backItem = childArray[childArray.length - 2];\n  }\n\n  var buttonHrefValue = getHref(backItem);\n  var buttonTooltipValue = getTitle(backItem);\n  return /*#__PURE__*/React.createElement(ReactResizeDetector, {\n    onResize: handleResize\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: cx(blockClass, className, _defineProperty({}, \"\".concat(blockClass, \"__with-items\"), displayedBreadcrumbItems.length > 1)),\n    ref: breadcrumbItemWithOverflow\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: cx([\"\".concat(blockClass, \"__space\")])\n  }, /*#__PURE__*/React.createElement(ReactResizeDetector, {\n    onResize: handleBreadcrumbItemsResize\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"\".concat(blockClass, \"__breadcrumb-container \").concat(blockClass, \"__breadcrumb-container--hidden\"),\n    \"aria-hidden\": true,\n    ref: sizingContainerRef\n  }, /*#__PURE__*/React.createElement(Breadcrumb, null, /*#__PURE__*/React.createElement(BreadcrumbItem, {\n    key: \"\".concat(blockClass, \"-hidden-overflow-\").concat(internalId)\n  }, /*#__PURE__*/React.createElement(OverflowMenu, {\n    ariaLabel: overflowAriaLabel,\n    renderIcon: OverflowMenuHorizontal32\n  })), children))), buttonHrefValue && buttonTooltipValue && /*#__PURE__*/React.createElement(Button, {\n    className: \"\".concat(blockClass, \"--breadcrumb-back-button\"),\n    hasIconOnly: true,\n    iconDescription: buttonTooltipValue,\n    kind: \"ghost\",\n    href: buttonHrefValue || '#',\n    renderIcon: ArrowLeft16,\n    size: \"field\",\n    tooltipPosition: \"right\",\n    type: \"button\"\n  }), /*#__PURE__*/React.createElement(Breadcrumb, _extends({\n    className: cx(\"\".concat(blockClass, \"__breadcrumb-container\"), _defineProperty({}, \"\".concat(blockClass, \"__breadcrumb-container-with-items\"), displayedBreadcrumbItems.length > 1)),\n    noTrailingSlash: noTrailingSlash\n  }, other), displayedBreadcrumbItems))));\n}; // Return a placeholder if not released and not enabled by feature flag\n\nBreadcrumbWithOverflow = pkg.checkComponentEnabled(BreadcrumbWithOverflow, componentName);\nBreadcrumbWithOverflow.propTypes = {\n  /**\n   * children of the breadcrumb-item set (these are expected to be breadcrumb-items)\n   */\n  children: PropTypes.arrayOf(PropTypes.element),\n\n  /**\n   * className\n   */\n  className: PropTypes.string,\n\n  /**\n   * maxVisble: maximum visible breadcrumb-items before overflow is used (values less than 1 are treated as 1)\n   */\n  maxVisible: PropTypes.number,\n\n  /**\n   * noTrailing slash - same as for Carbon\n   */\n  noTrailingSlash: PropTypes.bool,\n\n  /**\n   * overflowAriaLabel label for open close button overflow used for action bar items that do nto fit.\n   */\n  overflowAriaLabel: PropTypes.string\n};\nBreadcrumbWithOverflow.defaultProps = {\n  overflowAriaLabel: 'Open and close additional breadcrumb item list.',\n  noTrailingSlash: false\n};\nBreadcrumbWithOverflow.displayName = componentName;","map":null,"metadata":{},"sourceType":"module"}