{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} //\n// Copyright IBM Corp. 2020, 2021\n//\n// This source code is licensed under the Apache-2.0 license found in the\n// LICENSE file in the root directory of this source tree.\n//\n\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport unwrapIfFragment from './unwrap-if-fragment';\nimport pconsole from './pconsole'; // helper functions for component props\n\n/**\n * Prepare a set of props, or prop types or default props, merging values\n * from one or more sets and optionally blocking keys which should not be\n * passed. Returns the prepared set of props. Does not modify any of the\n * objects passed.\n *\n * @param {{} | '' | ['']} values One or more sets of keys and values to be\n * merged, or names of keys to be blocked. Each parameter that is an object is\n * treated as keys and values to be merged, and each parameter that is a string\n * or an array of strings is treated as keys to be blocked.\n *\n * Examples:\n *   const props = { a: 3, c: 4, d: 5 };\n *\n *   * prepareProps(props) -> { a: 3, c: 4, d: 5 }\n *   * prepareProps(props, 'c') -> { a: 3, d: 5 }\n *   * prepareProps(props, ['a', 'c', 'e']) -> { d: 5 }\n *\n *   * prepareProps({ a: 1, b: 2 }, props) -> { a: 3, b: 2, c: 4, d: 5 }\n *   * prepareProps({ a: 1, b: 2 }, props, ['a', 'c']) -> { b: 2, d: 5 }\n *\n *   * prepareProps(props, { c: 6 }) -> { a: 3, c: 6, d: 5 }\n *   * prepareProps(props, 'a', { c: 6 }) -> { c: 6, d: 5 }\n */\n\nexport var prepareProps = function prepareProps() {\n  // Convert any string or array arg into an object with nulls as values\n  var toNulls = function toNulls(arg) {\n    return typeof arg === 'string' ? _defineProperty({}, arg, null) : Array.isArray(arg) ? Object.fromEntries(arg.map(function (key) {\n      return [key, null];\n    })) : arg;\n  }; // Merge all the args from left to right\n\n\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  var merged = Object.assign.apply(Object, [{}].concat(_toConsumableArray(values.map(toNulls)))); // Now strip any keys whose final value is null\n\n  return Object.entries(merged).reduce(function (result, _ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        key = _ref3[0],\n        value = _ref3[1];\n\n    if (value !== null) {\n      result[key] = value;\n    }\n\n    return result;\n  }, {});\n}; // A simple wrapper for a prop-types checker that issues a warning message if\n// the value being validated is not null/undefined.\n\nvar deprecatePropInner = function deprecatePropInner(message, validator, info) {\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    } // args = [props, propName, componentName, location, propFullName, ...]\n\n\n    args[0][args[1]] && pconsole.warn(message(args[3], args[4] || args[1], args[2], info));\n    return validator.apply(void 0, args);\n  };\n};\n/**\n * A prop-types type checker that marks a particular usage of a prop as\n * deprecated. This can be used to deprecate an option in a oneOfType checker,\n * and the deprecated option(s) should be listed last so that the deprecation\n * message is only reported if none of the other type options is matched.\n * @param {} validator The prop-types validator for the prop usage as it should\n * be if it weren't deprecated. If this validator produces type checking\n * errors they will be reported as usual.\n * @param {*} additionalInfo One or more sentences to be appended to the\n * deprecation message to explain why the prop usage is deprecated and/or what\n * should be used instead.\n * @returns Any type checking error reported by the validator, or null.\n */\n\n\nexport var deprecatePropUsage = deprecatePropInner.bind(undefined, function (location, propName, componentName, info) {\n  return \"The usage of the \".concat(location, \" `\").concat(propName, \"` of `\").concat(componentName, \"` has been changed and support for the old usage will soon be removed. \").concat(info);\n});\n/**\n * A prop-types type checker that marks a prop as deprecated.\n * @param {} validator The prop-types validator for the prop as it should be\n * used if it weren't deprecated. If this validator produces type checking\n * errors they will be reported as usual.\n * @param {*} additionalInfo One or more sentences to be appended to the\n * deprecation message to explain why the prop is deprecated and/or what should\n * be used instead.\n * @returns Any type checking error reported by the validator, or null.\n */\n\nexport var deprecateProp = deprecatePropInner.bind(undefined, function (location, propName, componentName, info) {\n  return \"The \".concat(location, \" `\").concat(propName, \"` of `\").concat(componentName, \"` has been deprecated and will soon be removed. \").concat(info);\n});\n/**\n * Takes items as fragment, node or array\n * @param {node || array} items - which may have shape to extract\n * @returns Array of items\n */\n\nexport var extractShapesArray = function extractShapesArray(items) {\n  var _items$, _items$2; // unwrap if items or the first index looks like a React element or fragment\n\n\n  if (items && (items !== null && items !== void 0 && (_items$ = items[0]) !== null && _items$ !== void 0 && _items$.props || (items === null || items === void 0 ? void 0 : (_items$2 = items[0]) === null || _items$2 === void 0 ? void 0 : _items$2.type) === React.Fragment || items.type === React.Fragment)) {\n    return unwrapIfFragment(items).map(function (item) {\n      return _objectSpread({}, item.props);\n    });\n  }\n\n  return Array.isArray(items) ? items : [];\n};\n/**\n * A prop-types validation function that takes an array of type checkers and\n * requires prop values to satisfy all of the type checkers. This can be useful\n * to combine custom validation functions with regular prop types, or for\n * combining inherited prop-types from another component with tighter\n * requirements.\n *\n * Examples:\n *\n * MyComponent.propTypes = {\n *\n *   foo: allPropTypes([\n *     customValidationFunction,\n *     PropTypes.arrayOf(\n *       PropTypes.shape({\n *         text: PropType.string\n *       })\n *     )\n *   ]),\n *\n *   kind: allPropTypes([\n *     Button.propTypes.kind,\n *     PropTypes.oneOf('primary', 'secondary')\n *   ]),\n *\n * }\n */\n\nexport var allPropTypes = pconsole.shimIfProduction(function (arrayOfTypeCheckers) {\n  if (!Array.isArray(arrayOfTypeCheckers)) {\n    pconsole.error('Warning: Invalid argument supplied to allPropTypes, expected an instance of array.');\n    return pconsole.noop;\n  }\n\n  for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n    if (typeof arrayOfTypeCheckers[i] !== 'function') {\n      pconsole.error(\"Invalid argument supplied to allPropTypes. Expected an array of check functions, but received \".concat(arrayOfTypeCheckers[i], \" at index \").concat(i, \".\"));\n      return pconsole.noop;\n    }\n  }\n\n  var checkType = function checkType() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    var error = null;\n    arrayOfTypeCheckers.some(function (checker) {\n      return error = checker.apply(void 0, args);\n    });\n    return error;\n  };\n\n  checkType.isRequired = function (props, propName, comp, loc, propFullName, secret) {\n    var prop = propFullName || propName;\n    return props[prop] == null ? new Error(\"The \".concat(loc, \" `\").concat(prop, \"` is marked as required in `\").concat(comp || '<<anonymous>>', \"`, but its value is `\").concat(props[prop] === null ? 'null' : 'undefined', \"`.\")) : checkType(props, prop, comp, loc, propFullName, secret);\n  };\n\n  return checkType;\n});\n/**\n * A prop-types validation function that takes a type checkers and a condition\n * function and invokes either the type checker or the isRequired variant of\n * the type checker according to whether the condition function returns false\n * or true when called with the full set of props. This can be useful to make\n * a prop conditionally required. The function also has a decorate function\n * which can be used to add isRequiredIf to any existing type which already has\n * an isRequired variant, and this is automatically applied to the simple type\n * checkers in PropTypes when this props-helper module is imported. The second\n * example produces better results with DocGen and Storybook.\n *\n * Examples:\n *\n * MyComponent1.propTypes = {\n *   showFoo: PropTypes.bool,\n *   fooLabel: isRequiredIf(PropTypes.string, ({ showFoo }) => showFoo),\n * }\n *\n * MyComponent2.propTypes = {\n *   showBar: PropTypes.bool,\n *   barLabel: PropTypes.string.isRequired.if(({ showBar }) => showBar),\n * }\n *\n */\n\nexport var isRequiredIf = function isRequiredIf(checker, conditionFn) {\n  return function (props, propName, componentName, location, propFullName, secret) {\n    return (conditionFn(props) ? checker.isRequired : checker)(props, propName, componentName, location, propFullName, secret);\n  };\n};\n\nisRequiredIf.decorate = function (checker) {\n  checker.isRequired.if = pconsole.isProduction ? pconsole.noop : isRequiredIf.bind(null, checker);\n};\n\nfor (var checker in PropTypes) {\n  if (PropTypes[checker].isRequired) {\n    isRequiredIf.decorate(PropTypes[checker]);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}