{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n/**\n * Copyright IBM Corp. 2016, 2018\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nimport cx from 'classnames';\nimport React, { useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { settings } from 'carbon-components';\nimport debounce from 'lodash.debounce';\nimport setupGetInstanceId from '../../tools/setupGetInstanceId';\nimport { composeEventHandlers } from '../../tools/events';\nimport { keys, matches } from '../../internal/keyboard';\nvar prefix = settings.prefix;\nvar getInstanceId = setupGetInstanceId();\n\nvar TooltipDefinition = function TooltipDefinition(_ref) {\n  var _cx;\n\n  var id = _ref.id,\n      className = _ref.className,\n      triggerClassName = _ref.triggerClassName,\n      children = _ref.children,\n      direction = _ref.direction,\n      align = _ref.align,\n      onBlur = _ref.onBlur,\n      onFocus = _ref.onFocus,\n      onMouseEnter = _ref.onMouseEnter,\n      onMouseLeave = _ref.onMouseLeave,\n      tooltipText = _ref.tooltipText,\n      rest = _objectWithoutProperties(_ref, [\"id\", \"className\", \"triggerClassName\", \"children\", \"direction\", \"align\", \"onBlur\", \"onFocus\", \"onMouseEnter\", \"onMouseLeave\", \"tooltipText\"]);\n\n  var _useState = useState(true),\n      _useState2 = _slicedToArray(_useState, 2),\n      allowTooltipVisibility = _useState2[0],\n      setAllowTooltipVisibility = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      tooltipVisible = _useState4[0],\n      setTooltipVisible = _useState4[1];\n\n  var tooltipId = id || \"definition-tooltip-\".concat(getInstanceId());\n  var tooltipClassName = cx(\"\".concat(prefix, \"--tooltip--definition\"), \"\".concat(prefix, \"--tooltip--a11y\"), className);\n  var tooltipTriggerClasses = cx(\"\".concat(prefix, \"--tooltip__trigger\"), \"\".concat(prefix, \"--tooltip--a11y\"), \"\".concat(prefix, \"--tooltip__trigger--definition\"), triggerClassName, (_cx = {}, _defineProperty(_cx, \"\".concat(prefix, \"--tooltip--\").concat(direction), direction), _defineProperty(_cx, \"\".concat(prefix, \"--tooltip--align-\").concat(align), align), _defineProperty(_cx, \"\".concat(prefix, \"--tooltip--hidden\"), !allowTooltipVisibility), _defineProperty(_cx, \"\".concat(prefix, \"--tooltip--visible\"), tooltipVisible), _cx));\n  var debounceTooltipVisible = debounce(function () {\n    return setTooltipVisible(false);\n  }, 100);\n\n  var handleFocus = function handleFocus() {\n    debounceTooltipVisible.cancel();\n    setAllowTooltipVisibility(true);\n    setTooltipVisible(true);\n  };\n\n  var handleBlur = debounceTooltipVisible;\n\n  var handleMouseEnter = function handleMouseEnter() {\n    debounceTooltipVisible.cancel();\n    setAllowTooltipVisibility(true);\n    setTooltipVisible(true);\n  };\n\n  var handleMouseLeave = debounceTooltipVisible;\n  useEffect(function () {\n    var handleEscKeyDown = function handleEscKeyDown(event) {\n      if (matches(event, [keys.Escape])) {\n        setAllowTooltipVisibility(false);\n      }\n    };\n\n    document.addEventListener('keydown', handleEscKeyDown);\n    return function () {\n      return document.removeEventListener('keydown', handleEscKeyDown);\n    };\n  }, []);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({}, rest, {\n    className: tooltipClassName,\n    onMouseEnter: composeEventHandlers([onMouseEnter, handleMouseEnter]),\n    onMouseLeave: composeEventHandlers([onMouseLeave, handleMouseLeave])\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    type: \"button\",\n    className: tooltipTriggerClasses,\n    \"aria-describedby\": tooltipId,\n    onFocus: composeEventHandlers([onFocus, handleFocus]),\n    onBlur: composeEventHandlers([onBlur, handleBlur])\n  }, children), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"\".concat(prefix, \"--assistive-text\"),\n    id: tooltipId,\n    role: \"tooltip\"\n  }, tooltipText));\n};\n\nTooltipDefinition.propTypes = {\n  /**\n   * Specify the alignment (to the trigger button) of the tooltip.\n   * Can be one of: start, center, or end.\n   */\n  align: PropTypes.oneOf(['start', 'center', 'end']),\n\n  /**\n   * Specify the tooltip trigger text that is rendered to the UI for the user to\n   * interact with in order to display the tooltip.\n   */\n  children: PropTypes.node.isRequired,\n\n  /**\n   * Specify an optional className to be applied to the container node\n   */\n  className: PropTypes.string,\n\n  /**\n   * Specify the direction of the tooltip. Can be either top or bottom.\n   */\n  direction: PropTypes.oneOf(['top', 'bottom']),\n\n  /**\n   * Optionally specify a custom id for the tooltip. If one is not provided, we\n   * generate a unique id for you.\n   */\n  id: PropTypes.string,\n\n  /**\n   * The event handler for the `blur` event.\n   */\n  onBlur: PropTypes.func,\n\n  /**\n   * The event handler for the `focus` event.\n   */\n  onFocus: PropTypes.func,\n\n  /**\n   * The event handler for the `mouseenter` event.\n   */\n  onMouseEnter: PropTypes.func,\n\n  /**\n   * The event handler for the `mouseleave` event.\n   */\n  onMouseLeave: PropTypes.func,\n\n  /**\n   * Provide the text that will be displayed in the tooltip when it is rendered.\n   * TODO: rename this prop (will be a breaking change)\n   */\n  tooltipText: PropTypes.node.isRequired,\n\n  /**\n   * The CSS class name of the trigger element\n   */\n  triggerClassName: PropTypes.string\n};\nTooltipDefinition.defaultProps = {\n  direction: 'bottom',\n  align: 'start'\n};\nexport default TooltipDefinition;","map":null,"metadata":{},"sourceType":"module"}