{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { pkg } from '../../settings';\nexport var blockClass = \"\".concat(pkg.prefix, \"--page-header\");\n/**\n * Assesses the vertical height of various elements and calls setMetrics with update\n * @param {{}} headerRef\n * @param {{}} navigation\n * @param {boolean} preventBreadcrumbScroll\n * @param {()} setMetrics\n */\n\nexport var utilCheckUpdateVerticalSpace = function utilCheckUpdateVerticalSpace(headerRef, navigation, preventBreadcrumbScroll, setMetrics) {\n  var dynamicRefs = {};\n\n  var getDynamicRef = function getDynamicRef(selector) {\n    // would love to do this differently but digging in the dom seems easier\n    // than getting a ref to a conditionally rendered item\n\n    /* don't know how to test resize */\n\n    /* istanbul ignore next if */\n    if (!headerRef.current) {\n      return undefined;\n    } else {\n      var dRef = dynamicRefs[selector];\n\n      if (!dRef || dRef.parentNode === null) {\n        dynamicRefs[selector] = headerRef.current.querySelector(selector);\n      }\n    }\n\n    return dynamicRefs[selector];\n  }; // Utility function that checks the heights of various elements which are used to determine layout\n\n\n  var update = {};\n  var breadcrumbTitleEl = getDynamicRef(\".\".concat(blockClass, \"__breadcrumb-title\"));\n  var breadcrumbRowEl = getDynamicRef(\".\".concat(blockClass, \"__breadcrumb-row\"));\n  var titleRowEl = getDynamicRef(\".\".concat(blockClass, \"__title-row\"));\n  var subtitleRowEl = getDynamicRef(\".\".concat(blockClass, \"__subtitle-row\"));\n  var availableRowEl = getDynamicRef(\".\".concat(blockClass, \"__available-row\"));\n  var navigationRowEl = getDynamicRef(\".\".concat(blockClass, \"__navigation-row\"));\n  update.headerHeight = headerRef.current ? headerRef.current.clientHeight : 0;\n  update.headerWidth = headerRef.current ? headerRef.current.offsetWidth : 0;\n  update.breadcrumbRowHeight = breadcrumbRowEl ? breadcrumbRowEl.clientHeight : 0;\n  update.breadcrumbRowWidth = breadcrumbRowEl ? breadcrumbRowEl.offsetWidth : 0;\n  update.breadcrumbTitleHeight = breadcrumbTitleEl ? breadcrumbTitleEl.clientHeight : 1;\n  update.titleRowHeight = titleRowEl ? titleRowEl.clientHeight : 0;\n  update.subtitleRowHeight = subtitleRowEl ? subtitleRowEl.clientHeight : 0;\n  update.availableRowHeight = availableRowEl ? availableRowEl.clientHeight : 0;\n  update.navigationRowHeight = navigationRowEl ? navigationRowEl.clientHeight : 1;\n  update.breadcrumbRowSpaceBelow = 0;\n  update.titleRowSpaceAbove = 0; // Base for calculating sticky top\n\n  update.headerTopValue = -update.headerHeight;\n\n  if (navigation) {\n    // adjust top for sticky with navigation\n    update.headerTopValue += update.navigationRowHeight;\n  }\n\n  if (preventBreadcrumbScroll || !navigation) {\n    // adjust sticky top if no navigation or breadcrumb is to stay on screen\n    update.headerTopValue += update.breadcrumbRowHeight;\n  }\n\n  if (window) {\n    var val;\n    /* don't know how to test resize */\n\n    /* istanbul ignore next if */\n\n    if (breadcrumbRowEl) {\n      val = parseFloat(window.getComputedStyle(breadcrumbRowEl).getPropertyValue('margin-bottom'), 10);\n      update.breadcrumbRowSpaceBelow = isNaN(val) ? 0 : val;\n    }\n    /* don't know how to test resize */\n\n    /* istanbul ignore next if */\n\n\n    if (titleRowEl) {\n      val = parseFloat(window.getComputedStyle(titleRowEl).getPropertyValue('margin-top'), 10);\n      update.titleRowSpaceAbove = isNaN(val) ? 0 : val;\n    }\n  }\n\n  setMetrics(function (previous) {\n    return _objectSpread(_objectSpread({}, previous), update);\n  });\n};\n/**\n * Takes the title parameters and returns a titleShape\n * @param {{} | string} title\n * @param {{}} titleIcon\n * @param {string} defaultTitle\n * @returns\n */\n\nexport var utilGetTitleShape = function utilGetTitleShape(title, titleIcon, defaultTitle) {\n  // Title shape is used to allow title to be string or shape\n  var newShape = _objectSpread({}, defaultTitle);\n\n  if (title) {\n    if (title.text) {\n      // title is in shape format\n      newShape = Object.assign(newShape, _objectSpread({}, title));\n    } else {\n      // title is a string\n      newShape.text = title;\n    }\n  }\n\n  if (!newShape.icon && titleIcon) {\n    // if no icon use titleIcon if supplied\n    newShape.icon = titleIcon;\n  }\n\n  return newShape;\n}; // Set css style values directly onto a node. Note that this is effective\n// immediately, rather than using the React `style` prop which goes through\n// the React DOM update optimisation.\n\nexport var utilSetCustomCSSProps = function utilSetCustomCSSProps(targetRef, kvPairs) {\n  if (targetRef.current) {\n    var keys = Object.keys(kvPairs);\n\n    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n      var k = _keys[_i];\n      targetRef.current.style.setProperty(k, kvPairs[k]);\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}