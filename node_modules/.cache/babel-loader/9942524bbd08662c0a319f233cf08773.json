{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"accept\", \"className\", \"defaultErrorBody\", \"defaultErrorHeader\", \"description\", \"fetchErrorBody\", \"fetchErrorHeader\", \"fileDropHeader\", \"fileDropLabel\", \"fileUploadLabel\", \"inputButtonText\", \"inputId\", \"inputLabel\", \"inputPlaceholder\", \"invalidFileTypeErrorBody\", \"invalidFileTypeErrorHeader\", \"invalidIconDescription\", \"maxFileSize\", \"maxFileSizeErrorBody\", \"maxFileSizeErrorHeader\", \"onClose\", \"onRequestSubmit\", \"open\", \"primaryButtonText\", \"secondaryButtonText\", \"title\"];\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} //\n// Copyright IBM Corp. 2021, 2021\n//\n// This source code is licensed under the Apache-2.0 license found in the\n// LICENSE file in the root directory of this source tree.\n//\n\n\nimport React, { useState, forwardRef } from 'react';\nimport { ComposedModal, ModalHeader, ModalFooter, ModalBody, FileUploaderDropContainer, FileUploaderItem, TextInput, Button } from 'carbon-components-react';\nimport cx from 'classnames';\nimport PropTypes from 'prop-types';\nimport uuidv4 from '../../global/js/utils/uuidv4';\nimport { pkg } from '../../settings';\nvar componentName = 'ImportModal';\nexport var ImportModal = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var accept = _ref.accept,\n      className = _ref.className,\n      defaultErrorBody = _ref.defaultErrorBody,\n      defaultErrorHeader = _ref.defaultErrorHeader,\n      description = _ref.description,\n      fetchErrorBody = _ref.fetchErrorBody,\n      fetchErrorHeader = _ref.fetchErrorHeader,\n      fileDropHeader = _ref.fileDropHeader,\n      fileDropLabel = _ref.fileDropLabel,\n      fileUploadLabel = _ref.fileUploadLabel,\n      inputButtonText = _ref.inputButtonText,\n      inputId = _ref.inputId,\n      inputLabel = _ref.inputLabel,\n      inputPlaceholder = _ref.inputPlaceholder,\n      invalidFileTypeErrorBody = _ref.invalidFileTypeErrorBody,\n      invalidFileTypeErrorHeader = _ref.invalidFileTypeErrorHeader,\n      invalidIconDescription = _ref.invalidIconDescription,\n      maxFileSize = _ref.maxFileSize,\n      maxFileSizeErrorBody = _ref.maxFileSizeErrorBody,\n      maxFileSizeErrorHeader = _ref.maxFileSizeErrorHeader,\n      onClose = _ref.onClose,\n      onRequestSubmit = _ref.onRequestSubmit,\n      open = _ref.open,\n      primaryButtonText = _ref.primaryButtonText,\n      secondaryButtonText = _ref.secondaryButtonText,\n      title = _ref.title,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  var _useState = useState([]),\n      _useState2 = _slicedToArray(_useState, 2),\n      files = _useState2[0],\n      setFiles = _useState2[1];\n\n  var _useState3 = useState(''),\n      _useState4 = _slicedToArray(_useState3, 2),\n      importUrl = _useState4[0],\n      setImportUrl = _useState4[1];\n\n  var isInvalidFileType = function isInvalidFileType(file) {\n    var acceptSet = new Set(accept);\n    var name = file.name;\n    var mimeType = file.type;\n    var extension = name.split('.').pop();\n\n    if (acceptSet.has(mimeType) || acceptSet.has(extension)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  var updateFiles = function updateFiles(newFiles) {\n    var updatedFiles = newFiles.map(function (file) {\n      var newFile = {\n        uuid: file.uuid || uuidv4(),\n        status: 'edit',\n        iconDescription: invalidIconDescription,\n        name: file.name,\n        filesize: file.size,\n        invalidFileType: file.invalidFileType,\n        fileData: file,\n        fetchError: file.fetchError\n      };\n\n      if (newFile.fetchError) {\n        newFile.errorBody = fetchErrorBody || defaultErrorBody;\n        newFile.errorSubject = fetchErrorHeader || defaultErrorHeader;\n        newFile.invalid = true;\n      } else if (newFile.invalidFileType) {\n        newFile.errorBody = invalidFileTypeErrorBody || defaultErrorBody;\n        newFile.errorSubject = invalidFileTypeErrorHeader || defaultErrorHeader;\n        newFile.invalid = true;\n      } else if (maxFileSize && newFile.filesize > maxFileSize) {\n        newFile.errorBody = maxFileSizeErrorBody || defaultErrorBody;\n        newFile.errorSubject = maxFileSizeErrorHeader || defaultErrorHeader;\n        newFile.invalid = true;\n      }\n\n      return newFile;\n    });\n\n    var finalFiles = _toConsumableArray(updatedFiles);\n\n    setFiles(finalFiles);\n  };\n\n  var fetchFile = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(evt) {\n      var fileName, pendingFile, response, blob, fetchedFile, failedFile;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              evt.preventDefault();\n              fileName = importUrl.substring(importUrl.lastIndexOf('/') + 1).split('?')[0];\n              pendingFile = {\n                name: fileName,\n                status: 'uploading',\n                uuid: uuidv4()\n              };\n              setFiles([pendingFile]);\n              _context.prev = 4;\n              _context.next = 7;\n              return fetch(importUrl);\n\n            case 7:\n              response = _context.sent;\n\n              if (!(!response.ok || response.status !== 200)) {\n                _context.next = 10;\n                break;\n              }\n\n              throw new Error(response.status);\n\n            case 10:\n              _context.next = 12;\n              return response.blob();\n\n            case 12:\n              blob = _context.sent;\n              fetchedFile = new File([blob], fileName, {\n                type: blob.type\n              });\n              fetchedFile.invalidFileType = isInvalidFileType(fetchedFile);\n              fetchedFile.uuid = pendingFile.uuid;\n              updateFiles([fetchedFile]);\n              _context.next = 23;\n              break;\n\n            case 19:\n              _context.prev = 19;\n              _context.t0 = _context[\"catch\"](4);\n              failedFile = _objectSpread(_objectSpread({}, pendingFile), {}, {\n                fetchError: true\n              });\n              updateFiles([failedFile]);\n\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[4, 19]]);\n    }));\n\n    return function fetchFile(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var onAddFile = function onAddFile(evt, _ref3) {\n    var addedFiles = _ref3.addedFiles;\n    evt.stopPropagation();\n    updateFiles(addedFiles);\n  };\n\n  var onRemoveFile = function onRemoveFile(uuid) {\n    var updatedFiles = files.filter(function (f) {\n      return f.uuid !== uuid;\n    });\n    setFiles(updatedFiles);\n  };\n\n  var onSubmitHandler = function onSubmitHandler() {\n    onRequestSubmit(files);\n  };\n\n  var inputHandler = function inputHandler(evt) {\n    setImportUrl(evt.target.value);\n  };\n\n  var numberOfFiles = files.length;\n  var numberOfValidFiles = files.filter(function (f) {\n    return !f.invalid;\n  }).length;\n  var hasFiles = numberOfFiles > 0;\n  var primaryButtonDisabled = !hasFiles || !(numberOfValidFiles > 0);\n  var importButtonDisabled = !importUrl || hasFiles;\n  var fileStatusString = \"\".concat(numberOfValidFiles, \" / \").concat(numberOfFiles, \" \").concat(fileUploadLabel);\n  var blockClass = \"\".concat(pkg.prefix, \"--import-modal\");\n  return /*#__PURE__*/React.createElement(ComposedModal, _extends({}, rest, {\n    open: open,\n    ref: ref,\n    onClose: onClose,\n    \"aria-label\": title,\n    className: cx(blockClass, className),\n    size: \"sm\",\n    preventCloseOnClickOutside: true\n  }), /*#__PURE__*/React.createElement(ModalHeader, {\n    className: \"\".concat(blockClass, \"__header\"),\n    title: title\n  }), /*#__PURE__*/React.createElement(ModalBody, {\n    className: \"\".concat(blockClass, \"__body-container\")\n  }, description && /*#__PURE__*/React.createElement(\"p\", {\n    className: \"\".concat(blockClass, \"__body\")\n  }, description), fileDropHeader && /*#__PURE__*/React.createElement(\"p\", {\n    className: \"\".concat(blockClass, \"__file-drop-header\")\n  }, fileDropHeader), /*#__PURE__*/React.createElement(FileUploaderDropContainer, {\n    accept: accept,\n    labelText: fileDropLabel,\n    onAddFiles: onAddFile,\n    disabled: hasFiles\n  }), inputLabel && /*#__PURE__*/React.createElement(\"p\", {\n    className: \"\".concat(blockClass, \"__label\")\n  }, inputLabel), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"\".concat(blockClass, \"__input-group\")\n  }, /*#__PURE__*/React.createElement(TextInput, {\n    labelText: \"\",\n    id: inputId,\n    onChange: inputHandler,\n    placeholder: inputPlaceholder,\n    value: importUrl,\n    disabled: hasFiles,\n    \"aria-label\": inputLabel\n  }), /*#__PURE__*/React.createElement(Button, {\n    onClick: fetchFile,\n    className: \"\".concat(blockClass, \"__import-button\"),\n    size: \"sm\",\n    disabled: importButtonDisabled\n  }, inputButtonText)), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"bx--file-container \".concat(blockClass, \"__file-container\")\n  }, hasFiles && /*#__PURE__*/React.createElement(\"p\", {\n    className: \"\".concat(blockClass, \"__helper-text\")\n  }, fileStatusString), files.map(function (file) {\n    return /*#__PURE__*/React.createElement(FileUploaderItem, {\n      key: file.uuid,\n      onDelete: function onDelete() {\n        return onRemoveFile(file.uuid);\n      },\n      name: file.name,\n      status: file.status,\n      size: \"default\",\n      uuid: file.uuid,\n      iconDescription: file.iconDescription,\n      invalid: file.invalid,\n      errorBody: file.errorBody,\n      errorSubject: file.errorSubject,\n      filesize: file.filesize\n    });\n  }))), /*#__PURE__*/React.createElement(ModalFooter, {\n    className: \"\".concat(blockClass, \"__footer\")\n  }, /*#__PURE__*/React.createElement(Button, {\n    type: \"button\",\n    kind: \"secondary\",\n    onClick: onClose\n  }, secondaryButtonText), /*#__PURE__*/React.createElement(Button, {\n    type: \"submit\",\n    kind: \"primary\",\n    onClick: onSubmitHandler,\n    disabled: primaryButtonDisabled\n  }, primaryButtonText)));\n}); // Return a placeholder if not released and not enabled by feature flag\n\nImportModal = pkg.checkComponentEnabled(ImportModal, componentName);\nImportModal.propTypes = {\n  /**\n   * Specifies the file types that are valid for importing\n   */\n  accept: PropTypes.array,\n\n  /**\n   * Optional class name\n   */\n  className: PropTypes.string,\n\n  /**\n   * The default message shown for an import error\n   */\n  defaultErrorBody: PropTypes.string.isRequired,\n\n  /**\n   * The default header that is displayed to show an error message\n   */\n  defaultErrorHeader: PropTypes.string.isRequired,\n\n  /**\n   * Content that is displayed inside the modal\n   */\n  description: PropTypes.string,\n\n  /**\n   * Optional error body to display specifically for a fetch error\n   */\n  fetchErrorBody: PropTypes.string,\n\n  /**\n   * Optional error header to display specifically for a fetch error\n   */\n  fetchErrorHeader: PropTypes.string,\n\n  /**\n   * Header for the drag and drop box\n   */\n  fileDropHeader: PropTypes.string,\n\n  /**\n   * Label for the drag and drop box\n   */\n  fileDropLabel: PropTypes.string,\n\n  /**\n   * Label that appears when a file is uploaded to show number of files (1 / 1)\n   */\n  fileUploadLabel: PropTypes.string,\n\n  /**\n   * Button text for import by url button\n   */\n  inputButtonText: PropTypes.string.isRequired,\n\n  /**\n   * ID for text input\n   */\n  inputId: PropTypes.string,\n\n  /**\n   * Header to display above import by url\n   */\n  inputLabel: PropTypes.string,\n\n  /**\n   * Placeholder for text input\n   */\n  inputPlaceholder: PropTypes.string,\n\n  /**\n   * Optional error message to display specifically for a invalid file type error\n   */\n  invalidFileTypeErrorBody: PropTypes.string,\n\n  /**\n   * Optional error header to display specifically for a invalid file type error\n   */\n  invalidFileTypeErrorHeader: PropTypes.string,\n\n  /**\n   * Description for delete file icon\n   */\n  invalidIconDescription: PropTypes.string,\n\n  /**\n   * File size limit in bytes\n   */\n  maxFileSize: PropTypes.number,\n\n  /**\n   * Optional error message to display specifically for a max file size error\n   */\n  maxFileSizeErrorBody: PropTypes.string,\n\n  /**\n   * Optional error header to display specifically for a max file size error\n   */\n  maxFileSizeErrorHeader: PropTypes.string,\n\n  /**\n   * Specify a handler for closing modal\n   */\n  onClose: PropTypes.func,\n\n  /**\n   * Specify a handler for \"submitting\" modal. Access the imported file via `file => {}`\n   */\n  onRequestSubmit: PropTypes.func,\n\n  /**\n   * Specify whether the Modal is currently open\n   */\n  open: PropTypes.bool,\n\n  /**\n   * Specify the text for the primary button\n   */\n  primaryButtonText: PropTypes.string.isRequired,\n\n  /**\n   * Specify the text for the secondary button\n   */\n  secondaryButtonText: PropTypes.string.isRequired,\n\n  /**\n   * The text displayed at the top of the modal\n   */\n  title: PropTypes.string.isRequired\n};\nImportModal.defaultProps = {\n  accept: []\n};\nImportModal.displayName = componentName;","map":null,"metadata":{},"sourceType":"module"}