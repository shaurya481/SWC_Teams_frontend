{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"className\", \"disabled\", \"kind\", \"label\", \"loading\", \"onClick\", \"size\"],\n    _excluded2 = [\"actions\", \"buttonSize\", \"className\", \"size\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * Copyright IBM Corp. 2021, 2021\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// Import portions of React that are needed.\n\n\nimport React from 'react'; // Other standard imports.\n\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { pkg } from '../../settings';\nimport { allPropTypes } from '../../global/js/utils/props-helper'; // Carbon and package components we use.\n\nimport { Button, ButtonSet, InlineLoading } from 'carbon-components-react';\nvar blockClass = \"\".concat(pkg.prefix, \"--action-set\");\nvar componentName = 'ActionSet'; // NOTE: the component SCSS is not imported here: it is rolled up separately.\n\nvar ActionSetButton = /*#__PURE__*/React.forwardRef(function (_ref, ref) {\n  var className = _ref.className,\n      disabled = _ref.disabled,\n      kind = _ref.kind,\n      label = _ref.label,\n      loading = _ref.loading,\n      onClick = _ref.onClick,\n      size = _ref.size,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(Button, _extends({}, // Pass through any other property values as HTML attributes.\n  rest, {\n    isExpressive: true,\n    className: cx(className, [\"\".concat(blockClass, \"__action-button\"), _defineProperty({}, \"\".concat(blockClass, \"__action-button--ghost\"), kind === 'ghost')]),\n    disabled: disabled || loading || false,\n    kind: kind,\n    onClick: onClick,\n    ref: ref,\n    size: size\n  }), label, loading && /*#__PURE__*/React.createElement(InlineLoading, null));\n});\nActionSetButton.displayName = 'ActionSetButton';\nActionSetButton.propTypes = _objectSpread(_objectSpread({}, Button.PropTypes), {}, {\n  kind: PropTypes.oneOf(['ghost', 'secondary', 'primary']),\n  label: PropTypes.string,\n  loading: PropTypes.bool\n});\nvar defaultKind = Button.defaultProps.kind;\n\nvar willStack = function willStack(size, numberOfActions) {\n  return size === 'xs' || size === 'sm' || size === 'md' && numberOfActions > 2;\n};\n/**\n * An ActionSet presents a set of action buttons, constructed from bundles\n * of prop values and applying some layout rules. When the size is 'xs' or 'sm'\n * the buttons are stacked, and should only include primary and secondary\n * kinds. When the size is 'md' the buttons are stacked if there are three or\n * more. When the size is 'md' or 'lg', two buttons share the horizontal space.\n * When the size is 'lg', three or more buttons use a quarter of the available\n * horizontal space, and if the size is 'xlg' or 'max' the buttons always use\n * a quarter of the available horizontal space. If there is a ghost button,\n * it appears at the left side. If there is a primary button it appears at the\n * right.\n */\n\n\nexport var ActionSet = /*#__PURE__*/React.forwardRef(function (_ref3, ref) {\n  var _actions$slice, _cx;\n\n  var actions = _ref3.actions,\n      buttonSize = _ref3.buttonSize,\n      className = _ref3.className,\n      size = _ref3.size,\n      rest = _objectWithoutProperties(_ref3, _excluded2);\n\n  var buttons = actions && ((_actions$slice = actions.slice) === null || _actions$slice === void 0 ? void 0 : _actions$slice.call(actions, 0)) || []; // We stack the buttons in a xs/sm set, or if there are three or more in a md set.\n\n  var stacking = willStack(size, buttons.length); // order the actions with ghost buttons first and primary buttons last\n  // (and the opposite way if we're stacking)\n\n  buttons.sort(function (action1, action2) {\n    var kind1 = action1.kind || defaultKind;\n    var kind2 = action2.kind || defaultKind;\n    return kind1 === 'ghost' || kind2 === 'primary' ? stacking ? 1 : -1 : kind1 === 'primary' || kind2 === 'ghost' ? stacking ? -1 : 1 : 0;\n  });\n  return /*#__PURE__*/React.createElement(ButtonSet, _extends({}, // Pass through any other property values as HTML attributes.\n  rest, {\n    className: cx(blockClass, className, (_cx = {}, _defineProperty(_cx, \"\".concat(blockClass, \"--row-single\"), !stacking && buttons.length === 1), _defineProperty(_cx, \"\".concat(blockClass, \"--row-double\"), !stacking && buttons.length === 2), _defineProperty(_cx, \"\".concat(blockClass, \"--row-triple\"), !stacking && buttons.length === 3), _defineProperty(_cx, \"\".concat(blockClass, \"--row-quadruple\"), !stacking && buttons.length >= 4), _defineProperty(_cx, \"\".concat(blockClass, \"--stacking\"), stacking), _cx), \"\".concat(blockClass, \"--\").concat(size)),\n    ref: ref,\n    role: \"presentation\",\n    stacked: stacking\n  }), buttons.map(function (action, index) {\n    return /*#__PURE__*/React.createElement(ActionSetButton, _extends({\n      key: action.key || index\n    }, action, {\n      size: buttonSize\n    }));\n  }));\n});\nActionSet.displayName = componentName;\n/**\n * A validator function to help validate the actions supplied for a particular\n * size of component. When the size is xs or sm, or md with three actions, the\n * buttons will be stacked and a maximum of three buttons is applied with no\n * ghosts unless the ghost is the only button. Otherwise a maximum of four\n * buttons with a maximum of one ghost is applied. In either case, a maximum\n * of one primary button is allowed.\n * @param sizeFn An optional function which will be passed all the props and\n * returns the size that the component should be treated as being: if not\n * provided, a 'size' prop is used to determine the size of the component.\n * @returns null if the actions meet the requirements, or an Error object with\n * an explanatory message.\n */\n\nActionSet.validateActions = function (sizeFn) {\n  return function (props, propName, componentName, location, propFullName) {\n    var name = propFullName || propName;\n    var prop = props[name];\n    var actions = prop && (prop === null || prop === void 0 ? void 0 : prop.length);\n    var problems = [];\n\n    if (actions > 0) {\n      var size = sizeFn ? sizeFn(props) : props.size;\n      var stacking = willStack(size, actions);\n\n      var countActions = function countActions(kind) {\n        return prop.filter(function (action) {\n          return (action.kind || defaultKind) === kind;\n        }).length;\n      };\n\n      var primaryActions = countActions('primary');\n      var secondaryActions = countActions('secondary');\n      var ghostActions = countActions('ghost');\n      stacking && actions > 3 && problems.push(\"you cannot have more than three actions in this size of \".concat(componentName));\n      actions > 4 && problems.push(\"you cannot have more than four actions in a \".concat(componentName));\n      primaryActions > 1 && problems.push(\"you cannot have more than one 'primary' action in a \".concat(componentName));\n      ghostActions > 1 && problems.push(\"you cannot have more than one 'ghost' action in a \".concat(componentName));\n      stacking && actions > 1 && ghostActions > 0 && problems.push(\"you cannot have a 'ghost' button in conjunction with other action types in this size of \".concat(componentName));\n      actions > primaryActions + secondaryActions + ghostActions && problems.push(\"you can only have 'primary', 'secondary' and 'ghost' buttons in a \".concat(componentName));\n    }\n\n    return problems.length > 0 ? new Error(\"Invalid \".concat(location, \" `\").concat(name, \"` supplied to `\").concat(componentName, \"`: \").concat(problems.join(', and '), \".\")) : null;\n  };\n};\n\nActionSet.propTypes = {\n  /**\n   * The action buttons to show. Each action is specified as an\n   * object with optional fields 'label' to supply the button label, 'kind'\n   * to select the button kind (must be 'primary', 'secondary' or 'ghost'),\n   * 'loading' to display a loading indicator, and 'onClick' to receive\n   * notifications when the button is clicked. Additional fields in the object\n   * will be passed to the Button component, and these can include 'disabled',\n   * 'ref', 'className', and any other Button props. Any other fields in the\n   * object will be passed through to the button element as HTML attributes.\n   *\n   * See https://react.carbondesignsystem.com/?path=/docs/components-button--default#component-api\n   */\n  actions: allPropTypes([ActionSet.validateActions(), PropTypes.arrayOf(PropTypes.shape(_objectSpread(_objectSpread({}, Button.propTypes), {}, {\n    kind: PropTypes.oneOf(['ghost', 'secondary', 'primary']),\n    label: PropTypes.string,\n    loading: PropTypes.bool,\n    // we duplicate this Button prop to improve the DocGen here\n    onClick: Button.propTypes.onClick\n  })))]),\n\n  /**\n   * The size of buttons to use for the actions. The allowed values are\n   * those for the size prop of carbon Button. If this prop is specified, all\n   * the buttons will be set to this size, overriding any 'size' values (if any)\n   * supplied in the actions array (if any).\n   */\n  buttonSize: Button.propTypes.size,\n\n  /**\n   * An optional class or classes to be added to the outermost element.\n   */\n  className: PropTypes.string,\n\n  /**\n   * The size of the action set. Different button arrangements are used at\n   * different sizes, to make best use of the available space.\n   */\n  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xlg', 'max'])\n};\nActionSet.defaultProps = {\n  size: 'md'\n};","map":null,"metadata":{},"sourceType":"module"}