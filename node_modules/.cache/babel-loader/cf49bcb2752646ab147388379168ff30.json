{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n/**\n * Copyright IBM Corp. 2016, 2018\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { CaretDown16 } from '@carbon/icons-react';\nimport classNames from 'classnames';\nimport { settings } from 'carbon-components';\nimport { keys, match, matches } from '../../internal/keyboard';\nimport uniqueId from '../../tools/uniqueId';\nvar prefix = settings.prefix;\nexport default function TreeNode(_ref) {\n  var _classNames, _objectSpread2;\n\n  var active = _ref.active,\n      children = _ref.children,\n      className = _ref.className,\n      depth = _ref.depth,\n      disabled = _ref.disabled,\n      isExpanded = _ref.isExpanded,\n      label = _ref.label,\n      onNodeFocusEvent = _ref.onNodeFocusEvent,\n      onNodeSelect = _ref.onSelect,\n      onToggle = _ref.onToggle,\n      onTreeSelect = _ref.onTreeSelect,\n      Icon = _ref.renderIcon,\n      selected = _ref.selected,\n      value = _ref.value,\n      rest = _objectWithoutProperties(_ref, [\"active\", \"children\", \"className\", \"depth\", \"disabled\", \"isExpanded\", \"label\", \"onNodeFocusEvent\", \"onSelect\", \"onToggle\", \"onTreeSelect\", \"renderIcon\", \"selected\", \"value\"]);\n\n  var _useRef = useRef(rest.id || uniqueId()),\n      id = _useRef.current;\n\n  var _useState = useState(isExpanded),\n      _useState2 = _slicedToArray(_useState, 2),\n      expanded = _useState2[0],\n      setExpanded = _useState2[1];\n\n  var currentNode = useRef(null);\n  var currentNodeLabel = useRef(null);\n  var nodesWithProps = React.Children.map(children, function (node) {\n    if ( /*#__PURE__*/React.isValidElement(node)) {\n      return /*#__PURE__*/React.cloneElement(node, {\n        active: active,\n        depth: depth + 1,\n        disabled: disabled,\n        onTreeSelect: onTreeSelect,\n        selected: selected,\n        tabIndex: !node.props.disabled && -1 || null\n      });\n    }\n  });\n  var isActive = active === id;\n  var isSelected = selected.includes(id);\n  var treeNodeClasses = classNames(className, \"\".concat(prefix, \"--tree-node\"), (_classNames = {}, _defineProperty(_classNames, \"\".concat(prefix, \"--tree-node--active\"), isActive), _defineProperty(_classNames, \"\".concat(prefix, \"--tree-node--disabled\"), disabled), _defineProperty(_classNames, \"\".concat(prefix, \"--tree-node--selected\"), isSelected), _defineProperty(_classNames, \"\".concat(prefix, \"--tree-node--with-icon\"), Icon), _defineProperty(_classNames, \"\".concat(prefix, \"--tree-leaf-node\"), !children), _defineProperty(_classNames, \"\".concat(prefix, \"--tree-parent-node\"), children), _classNames));\n  var toggleClasses = classNames(\"\".concat(prefix, \"--tree-parent-node__toggle-icon\"), _defineProperty({}, \"\".concat(prefix, \"--tree-parent-node__toggle-icon--expanded\"), expanded));\n\n  function handleToggleClick(event) {\n    if (onToggle) {\n      onToggle(event, {\n        id: id,\n        isExpanded: !expanded,\n        label: label,\n        value: value\n      });\n    }\n\n    setExpanded(!expanded);\n  }\n\n  function handleClick(event) {\n    event.stopPropagation();\n\n    if (!disabled) {\n      if (onTreeSelect) {\n        onTreeSelect(event, {\n          id: id,\n          label: label,\n          value: value\n        });\n      }\n\n      if (onNodeSelect) {\n        onNodeSelect(event, {\n          id: id,\n          label: label,\n          value: value\n        });\n      }\n\n      if (rest.onClick) {\n        rest.onClick(event);\n      }\n    }\n  }\n\n  function handleKeyDown(event) {\n    if (matches(event, [keys.ArrowLeft, keys.ArrowRight, keys.Enter])) {\n      event.stopPropagation();\n    }\n\n    if (match(event, keys.ArrowLeft)) {\n      var findParentTreeNode = function findParentTreeNode(node) {\n        if (node.classList.contains(\"\".concat(prefix, \"--tree-parent-node\"))) {\n          return node;\n        }\n\n        if (node.classList.contains(\"\".concat(prefix, \"--tree\"))) {\n          return null;\n        }\n\n        return findParentTreeNode(node.parentNode);\n      };\n\n      if (children && expanded) {\n        onToggle(event, {\n          id: id,\n          isExpanded: false,\n          label: label,\n          value: value\n        });\n        setExpanded(false);\n      } else {\n        var _findParentTreeNode;\n        /**\n         * When focus is on a leaf node or a closed parent node, move focus to\n         * its parent node (unless its depth is level 1)\n         */\n\n\n        (_findParentTreeNode = findParentTreeNode(currentNode.current.parentNode)) === null || _findParentTreeNode === void 0 ? void 0 : _findParentTreeNode.focus();\n      }\n    }\n\n    if (children && match(event, keys.ArrowRight)) {\n      if (expanded) {\n        /**\n         * When focus is on an expanded parent node, move focus to the first\n         * child node\n         */\n        currentNode.current.lastChild.firstChild.focus();\n      } else {\n        onToggle(event, {\n          id: id,\n          isExpanded: true,\n          label: label,\n          value: value\n        });\n        setExpanded(true);\n      }\n    }\n\n    if (matches(event, [keys.Enter, keys.Space])) {\n      event.preventDefault();\n      handleClick(event);\n    }\n\n    if (rest.onKeyDown) {\n      rest.onKeyDown(event);\n    }\n  }\n\n  function handleFocusEvent(event) {\n    if (event.type === 'blur' && rest.onBlur) {\n      rest.onBlur(event);\n    }\n\n    if (event.type === 'focus' && rest.onFocus) {\n      rest.onFocus(event);\n    }\n\n    onNodeFocusEvent && onNodeFocusEvent(event);\n  }\n\n  useEffect(function () {\n    /**\n     * Negative margin shifts node to align with the left side boundary of the\n     * tree\n     * Dynamically calculate padding to recreate tree node indentation\n     * - parent nodes have (depth + 1rem) left padding\n     * - leaf nodes have (depth + 2.5rem) left padding without icons (because\n     *   of expando icon + spacing)\n     * - leaf nodes have (depth + 2rem) left padding with icons (because of\n     *   reduced spacing between the expando icon and the node icon + label)\n     */\n    var calcOffset = function calcOffset() {\n      // parent node\n      if (children) {\n        return depth + 1;\n      } // leaf node with icon\n\n\n      if (Icon) {\n        return depth + 2;\n      } // leaf node without icon\n\n\n      return depth + 2.5;\n    };\n\n    if (currentNodeLabel.current) {\n      currentNodeLabel.current.style.marginLeft = \"-\".concat(calcOffset(), \"rem\");\n      currentNodeLabel.current.style.paddingLeft = \"\".concat(calcOffset(), \"rem\");\n    } // sync props and state\n\n\n    setExpanded(isExpanded);\n  }, [children, depth, Icon, isExpanded]);\n\n  var treeNodeProps = _objectSpread(_objectSpread({}, rest), {}, (_objectSpread2 = {}, _defineProperty(_objectSpread2, 'aria-current', isActive || null), _defineProperty(_objectSpread2, 'aria-selected', disabled ? null : isSelected), _defineProperty(_objectSpread2, 'aria-disabled', disabled), _defineProperty(_objectSpread2, \"className\", treeNodeClasses), _defineProperty(_objectSpread2, \"id\", id), _defineProperty(_objectSpread2, \"onBlur\", handleFocusEvent), _defineProperty(_objectSpread2, \"onClick\", handleClick), _defineProperty(_objectSpread2, \"onFocus\", handleFocusEvent), _defineProperty(_objectSpread2, \"onKeyDown\", handleKeyDown), _defineProperty(_objectSpread2, \"ref\", currentNode), _defineProperty(_objectSpread2, \"role\", 'treeitem'), _objectSpread2));\n\n  if (!children) {\n    return /*#__PURE__*/React.createElement(\"li\", treeNodeProps, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"\".concat(prefix, \"--tree-node__label\"),\n      ref: currentNodeLabel\n    }, Icon && /*#__PURE__*/React.createElement(Icon, {\n      className: \"\".concat(prefix, \"--tree-node__icon\")\n    }), label));\n  }\n\n  return /*#__PURE__*/React.createElement(\"li\", _extends({}, treeNodeProps, {\n    \"aria-expanded\": !!expanded\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"\".concat(prefix, \"--tree-node__label\"),\n    ref: currentNodeLabel\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    className: \"\".concat(prefix, \"--tree-parent-node__toggle\"),\n    disabled: disabled,\n    onClick: handleToggleClick\n  }, /*#__PURE__*/React.createElement(CaretDown16, {\n    className: toggleClasses\n  })), /*#__PURE__*/React.createElement(\"span\", {\n    className: \"\".concat(prefix, \"--tree-node__label__details\")\n  }, Icon && /*#__PURE__*/React.createElement(Icon, {\n    className: \"\".concat(prefix, \"--tree-node__icon\")\n  }), label)), expanded && /*#__PURE__*/React.createElement(\"ul\", {\n    role: \"group\",\n    className: \"\".concat(prefix, \"--tree-node__children\")\n  }, nodesWithProps));\n}\nTreeNode.propTypes = {\n  /**\n   * The value of the active node in the tree\n   */\n  active: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * Specify the children of the TreeNode\n   */\n  children: PropTypes.node,\n\n  /**\n   * Specify an optional className to be applied to the TreeNode\n   */\n  className: PropTypes.string,\n\n  /**\n   * TreeNode depth to determine spacing, automatically calculated by default\n   */\n  depth: PropTypes.number,\n\n  /**\n   * Specify if the TreeNode is disabled\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Specify if the TreeNode is expanded (only applicable to parent nodes)\n   */\n  isExpanded: PropTypes.bool,\n\n  /**\n   * Rendered label for the TreeNode\n   */\n  label: PropTypes.node,\n\n  /**\n   * Callback function for when the node receives or loses focus\n   */\n  onNodeFocusEvent: PropTypes.func,\n\n  /**\n   * Callback function for when the node is selected\n   */\n  onSelect: PropTypes.func,\n\n  /**\n   * Callback function for when a parent node is expanded or collapsed\n   */\n  onToggle: PropTypes.func,\n\n  /**\n   * Callback function for when any node in the tree is selected\n   */\n  onTreeSelect: PropTypes.func,\n\n  /**\n   * Optional prop to allow each node to have an associated icon.\n   * Can be a React component class\n   */\n  renderIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n\n  /**\n   * Array containing all selected node IDs in the tree\n   */\n  selected: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),\n\n  /**\n   * Specify the value of the TreeNode\n   */\n  value: PropTypes.string\n};","map":null,"metadata":{},"sourceType":"module"}