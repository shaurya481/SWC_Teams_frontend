"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ActionBar = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _settings = require("../../settings");

var _reactResizeDetector = _interopRequireDefault(require("react-resize-detector"));

var _carbonComponentsReact = require("carbon-components-react");

var _uuidv = _interopRequireDefault(require("../../global/js/utils/uuidv4"));

var _propsHelper = require("../../global/js/utils/props-helper");

var _ActionBarItem = require("./ActionBarItem");

var _excluded = ["actions", "children", "className", "maxVisible", "onWidthChange", "overflowAriaLabel", "rightAlign"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// The block part of our conventional BEM class names (blockClass__E--M).
var blockClass = "".concat(_settings.pkg.prefix, "--action-bar");
var componentName = 'ActionBar'; // NOTE: the component SCSS is not imported here: it is rolled up separately.

/**
 * The ActionBar is used internally by the PageHeader to wrap ActionBarItems.
 */

var ActionBar = /*#__PURE__*/_react.default.forwardRef(function (_ref, ref) {
  var actions = _ref.actions,
      children = _ref.children,
      className = _ref.className,
      maxVisible = _ref.maxVisible,
      onWidthChange = _ref.onWidthChange,
      overflowAriaLabel = _ref.overflowAriaLabel,
      rightAlign = _ref.rightAlign,
      rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

  var _useState = (0, _react.useState)(0),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      displayCount = _useState2[0],
      setDisplayCount = _useState2[1];

  var _useState3 = (0, _react.useState)([]),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      displayedItems = _useState4[0],
      setDisplayedItems = _useState4[1];

  var internalId = (0, _react.useRef)((0, _uuidv.default)());

  var _useState5 = (0, _react.useState)([]),
      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
      itemArray = _useState6[0],
      setItemArray = _useState6[1];

  var refDisplayedItems = (0, _react.useRef)(null);

  var ActionBarOverflowItems = function ActionBarOverflowItems(_ref2) {
    var overflowItems = _ref2.overflowItems;
    return /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.OverflowMenu, {
      ariaLabel: overflowAriaLabel,
      className: "".concat(blockClass, "__overflow-menu"),
      direction: "bottom",
      flipped: true,
      menuOptionsClass: "".concat(blockClass, "-options")
    }, overflowItems.map(function (item, index) {
      // This uses a copy of a menu item option
      // NOTE: Cannot use a real Tooltip icon below as it uses a <button /> the
      // div equivalent below is based on Carbon 10.25.0
      return /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.OverflowMenuItem, {
        className: "".concat(blockClass, "__overflow-menu-item"),
        key: "".concat(blockClass, "-overflow-").concat(internalId.current, "-").concat(index),
        itemText: /*#__PURE__*/_react.default.createElement("div", {
          className: "".concat(blockClass, "__overflow-menu-item-content"),
          "aria-describedby": "".concat(internalId, "--overflow-menu-item-label")
        }, /*#__PURE__*/_react.default.createElement("span", {
          className: "".concat(blockClass, "__overflow-menu-item-label"),
          id: "".concat(internalId, "--overflow-menu-item-label")
        }, item.props.iconDescription), /*#__PURE__*/_react.default.createElement(item.props.renderIcon, null))
      });
    }));
  };

  ActionBarOverflowItems.propTypes = {
    /**
     * overflowItems: items to bre shown in the ActionBar overflow menu
     */
    overflowItems: _propTypes.default.arrayOf(_propTypes.default.element)
  }; // create child array from children which may be a fragment

  (0, _react.useEffect)(function () {
    if (actions) {
      setItemArray(actions);
    } else {
      setItemArray((0, _propsHelper.extractShapesArray)(children));
    }
  }, [actions, children]); // creates displayed items based on displayCount and alignment

  (0, _react.useEffect)(function () {
    var newDisplayedItems = itemArray.map(function (item, index) {
      return /*#__PURE__*/_react.default.createElement(_ActionBarItem.ActionBarItem, (0, _extends2.default)({}, item, {
        key: "".concat(index)
      }));
    }); // extract any there are not room for to newOverflowItems

    var newOverflowItems = newDisplayedItems.splice(displayCount); // add overflow menu if needed

    if (newOverflowItems.length) {
      newDisplayedItems.push( /*#__PURE__*/_react.default.createElement(ActionBarOverflowItems, {
        overflowItems: newOverflowItems,
        key: "overflow-menu-".concat(internalId.current)
      }));
    }

    setDisplayedItems(newDisplayedItems);
  }, [itemArray, displayCount]); // determine display count based on space available and width of pageActions

  var checkFullyVisibleItems = function checkFullyVisibleItems() {
    var spaceAvailable = refDisplayedItems.current.offsetWidth;
    var actionBarItemWidth = refDisplayedItems.current.offsetHeight; // short cut measure width

    /* istanbul ignore next if */

    if (actionBarItemWidth > 0) {
      var mightFit = spaceAvailable / actionBarItemWidth; // visibleItems may include 1 overflow menu

      var visibleItems = maxVisible ? Math.min(itemArray.length, maxVisible + 1) // + 1 for overflow menu if needed
      : itemArray.length;
      var willFit = Math.min(Math.floor(mightFit), visibleItems);
      onWidthChange && onWidthChange({
        maxWidth: actionBarItemWidth * visibleItems,
        minWidth: actionBarItemWidth
      }); // action bar items are a fixed width

      if (willFit < itemArray.length) {
        willFit -= 1; // remove one for overflow menu
      }

      if (willFit < 1) {
        setDisplayCount(0);
      } else {
        setDisplayCount(willFit);
      }
    }
  };

  (0, _react.useEffect)(function () {
    checkFullyVisibleItems(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [maxVisible, itemArray]);

  var handleResize = function handleResize() {
    // width is the space available for all action bar items horizontally
    // the action bar items are squares so the height should be one item wide

    /* istanbul ignore next */
    // not sure how to fake window resize
    checkFullyVisibleItems();
  };

  return /*#__PURE__*/_react.default.createElement(_reactResizeDetector.default, {
    onResize: handleResize
  }, /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({}, rest, {
    className: (0, _classnames.default)([blockClass, className]),
    ref: ref
  }), /*#__PURE__*/_react.default.createElement("div", {
    ref: refDisplayedItems,
    className: (0, _classnames.default)(["".concat(blockClass, "__displayed-items"), (0, _defineProperty2.default)({}, "".concat(blockClass, "__displayed-items--right"), rightAlign)])
  }, displayedItems)));
});

exports.ActionBar = ActionBar;
ActionBar.displayName = componentName;
ActionBar.propTypes = {
  /**
   * Specifies the action bar items. Each item is specified as an object
   * with the properties of a Carbon Button in icon only form. Button kind, size, tooltipPosition,
   * tooltipAlignment and type are ignored.
   *
   * Carbon Button API https://react.carbondesignsystem.com/?path=/docs/components-button--default#component-api
   */
  actions: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.shape(_objectSpread(_objectSpread({}, (0, _propsHelper.prepareProps)(_carbonComponentsReact.Button.propTypes, ['kind', 'size', 'tooltipPosition', 'tooltipAlignment'])), {}, {
    iconDescription: _propTypes.default.string.isRequired,
    onClick: _carbonComponentsReact.Button.propTypes.onClick,
    renderIcon: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object]).isRequired
  })))]),

  /**
   * children of the action bar (action bar items)
   */
  children: (0, _propsHelper.deprecateProp)(_propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.element), _propTypes.default.element]), 'See documentation on the `actions` prop.'),
  // expects action bar item as array or in fragment,

  /**
   * className
   */
  className: _propTypes.default.string,

  /**
   * maxVisible : Maximum action bar items visible before going into the overflow menu
   */
  maxVisible: _propTypes.default.number,

  /**
   * onItemCountChange - event reporting maxWidth
   */
  onWidthChange: _propTypes.default.func,

  /**
   * overflowAriaLabel label for open close button overflow used for action bar items that do nto fit.
   */
  overflowAriaLabel: _propTypes.default.string,

  /**
   * align tags to right of available space
   */
  rightAlign: _propTypes.default.bool
};
ActionBar.defaultProps = {
  overflowAriaLabel: 'Open and close additional action bar items list.',
  rightAlign: false
};