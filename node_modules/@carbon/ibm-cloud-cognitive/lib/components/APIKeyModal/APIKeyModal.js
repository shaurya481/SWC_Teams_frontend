"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APIKeyModal = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _carbonComponentsReact = require("carbon-components-react");

var _iconsReact = require("@carbon/icons-react");

var _APIKeyDownloader = require("../APIKeyDownloader");

var _settings = require("../../settings");

var _excluded = ["apiKey", "apiKeyInputId", "apiKeyLabel", "apiKeyVisibility", "className", "copyButtonText", "createButtonText", "customSteps", "createHeader", "downloadBodyText", "downloadLinkText", "downloadable", "downloadableFileName", "error", "errorMessage", "loading", "loadingMessage", "body", "modalLabel", "nameHelperText", "nameInputId", "nameLabel", "namePlaceholder", "nameRequired", "nextStepButtonText", "onClose", "onRequestSubmit", "open", "previousStepButtonText", "secondaryButtonText", "successBody", "successHeader", "stepHeaders"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var componentName = 'APIKeyModal';
var APIKeyModal = /*#__PURE__*/(0, _react.forwardRef)(function (_ref, ref) {
  var apiKey = _ref.apiKey,
      apiKeyInputId = _ref.apiKeyInputId,
      apiKeyLabel = _ref.apiKeyLabel,
      apiKeyVisibility = _ref.apiKeyVisibility,
      className = _ref.className,
      copyButtonText = _ref.copyButtonText,
      createButtonText = _ref.createButtonText,
      customSteps = _ref.customSteps,
      createHeader = _ref.createHeader,
      downloadBodyText = _ref.downloadBodyText,
      downloadLinkText = _ref.downloadLinkText,
      downloadable = _ref.downloadable,
      downloadableFileName = _ref.downloadableFileName,
      error = _ref.error,
      errorMessage = _ref.errorMessage,
      loading = _ref.loading,
      loadingMessage = _ref.loadingMessage,
      body = _ref.body,
      modalLabel = _ref.modalLabel,
      nameHelperText = _ref.nameHelperText,
      nameInputId = _ref.nameInputId,
      nameLabel = _ref.nameLabel,
      namePlaceholder = _ref.namePlaceholder,
      nameRequired = _ref.nameRequired,
      nextStepButtonText = _ref.nextStepButtonText,
      onClose = _ref.onClose,
      onRequestSubmit = _ref.onRequestSubmit,
      open = _ref.open,
      previousStepButtonText = _ref.previousStepButtonText,
      secondaryButtonText = _ref.secondaryButtonText,
      successBody = _ref.successBody,
      successHeader = _ref.successHeader,
      stepHeaders = _ref.stepHeaders,
      rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

  var _useState = (0, _react.useState)(''),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      name = _useState2[0],
      setName = _useState2[1];

  var _useState3 = (0, _react.useState)(0),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      currentStep = _useState4[0],
      setCurrentStep = _useState4[1];

  var inputRef = (0, _react.useRef)();
  var hasSteps = Boolean(customSteps.length);
  var apiKeyLoaded = apiKey && !loading;
  var hasNextStep = hasSteps && currentStep < customSteps.length - 1;
  var hasPreviousStep = hasSteps && currentStep !== 0;
  (0, _react.useEffect)(function () {
    if (inputRef.current && open) {
      inputRef.current.focus();
    }
  }, [open]);

  var isPrimaryButtonDisabled = function isPrimaryButtonDisabled() {
    if (loading) {
      return true;
    }

    if (hasSteps && 'valid' in customSteps[currentStep]) {
      return !customSteps[currentStep].valid;
    }

    if (nameRequired && !name) {
      return true;
    }

    return false;
  };

  var getPrimaryButtonText = function getPrimaryButtonText() {
    if (apiKey) {
      return copyButtonText;
    }

    if (hasNextStep) {
      return nextStepButtonText;
    }

    return createButtonText;
  };

  var getSecondaryButtonText = function getSecondaryButtonText() {
    if (hasPreviousStep && !apiKeyLoaded) {
      return previousStepButtonText;
    }

    return secondaryButtonText;
  };

  var getHeader = function getHeader() {
    if (apiKeyLoaded) {
      return successHeader;
    } else if (hasSteps) {
      return stepHeaders[currentStep];
    }

    return createHeader;
  };

  var setNameHandler = function setNameHandler(evt) {
    setName(evt.target.value);
  };

  var onCloseHandler = function onCloseHandler() {
    setName('');
    setCurrentStep(0);
    onClose();
  };

  var submitHandler = function submitHandler(evt) {
    if (hasNextStep) {
      setCurrentStep(currentStep + 1);
    } else if (apiKeyLoaded) {
      navigator.clipboard.writeText(apiKey);
    } else {
      evt.preventDefault();
      onRequestSubmit();
    }
  };

  var onBackHandler = function onBackHandler() {
    if (hasPreviousStep && !apiKeyLoaded) {
      setCurrentStep(currentStep - 1);
    } else {
      onCloseHandler();
    }
  };

  var blockClass = "".concat(_settings.pkg.prefix, "--apikey-modal");
  return /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.ComposedModal, (0, _extends2.default)({}, rest, {
    open: open,
    ref: ref,
    className: (0, _classnames.default)(className, blockClass),
    onClose: onCloseHandler,
    size: "sm",
    preventCloseOnClickOutside: true
  }), /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.ModalHeader, {
    className: "".concat(blockClass, "__header"),
    title: getHeader(),
    label: hasPreviousStep ? modalLabel : ''
  }), /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.ModalBody, {
    className: "".concat(blockClass, "__body-container")
  }, hasSteps && !apiKeyLoaded ? customSteps[currentStep].content : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, body && /*#__PURE__*/_react.default.createElement("p", {
    className: "".concat(blockClass, "__body")
  }, body), apiKey && apiKeyVisibility && /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.TextInput.PasswordInput, {
    value: apiKey,
    labelText: apiKeyLabel,
    id: apiKeyInputId
  }), apiKey && !apiKeyVisibility && /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.TextInput, {
    value: apiKey,
    labelText: apiKeyLabel,
    id: apiKeyInputId
  }), nameRequired && !apiKeyLoaded && /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.Form, {
    onSubmit: submitHandler
  }, /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.TextInput, {
    helperText: nameHelperText,
    placeholder: namePlaceholder,
    labelText: nameLabel,
    onChange: function onChange(evt) {
      return setNameHandler(evt);
    },
    value: name,
    id: nameInputId,
    disabled: loading,
    ref: inputRef
  })), loading && /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.InlineLoading, {
    description: loadingMessage,
    className: "".concat(blockClass, "__loader")
  }), error && /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(blockClass, "__messaging")
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(blockClass, "__error-icon")
  }, /*#__PURE__*/_react.default.createElement(_iconsReact.ErrorFilled16, null)), /*#__PURE__*/_react.default.createElement("p", {
    className: "".concat(blockClass, "__messaging-text")
  }, errorMessage)), apiKeyLoaded && /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(blockClass, "__messaging")
  }, /*#__PURE__*/_react.default.createElement(_iconsReact.InformationFilled16, null), downloadable ? /*#__PURE__*/_react.default.createElement(_APIKeyDownloader.APIKeyDownloader, {
    apiKey: apiKey,
    bodyText: downloadBodyText,
    fileName: downloadableFileName,
    linkText: downloadLinkText
  }) : /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(blockClass, "__messaging-text")
  }, successBody)))), /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.ModalFooter, {
    className: "".concat(blockClass, "__footer")
  }, /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.Button, {
    type: "button",
    kind: "secondary",
    onClick: onBackHandler
  }, getSecondaryButtonText()), /*#__PURE__*/_react.default.createElement(_carbonComponentsReact.Button, (0, _extends2.default)({}, apiKeyLoaded ? {
    renderIcon: _iconsReact.Copy16
  } : {}, {
    type: "submit",
    kind: "primary",
    onClick: submitHandler,
    disabled: isPrimaryButtonDisabled()
  }), getPrimaryButtonText())));
}); // Return a placeholder if not released and not enabled by feature flag

exports.APIKeyModal = APIKeyModal;
exports.APIKeyModal = APIKeyModal = _settings.pkg.checkComponentEnabled(APIKeyModal, componentName);
APIKeyModal.propTypes = {
  /**
   * the api key the user receives
   */
  apiKey: _propTypes.default.string,

  /**
   * id for the api key input field
   */
  apiKeyInputId: _propTypes.default.string,

  /**
   * label for the api key input field
   */
  apiKeyLabel: _propTypes.default.string,

  /**
   * specifies if the api key input should use the password type toggle
   */
  apiKeyVisibility: _propTypes.default.bool,

  /**
   * content for modal body
   */
  body: _propTypes.default.string,

  /**
   * Optional classname
   */
  className: _propTypes.default.string,

  /**
   * text for the copy button
   */
  copyButtonText: _propTypes.default.string.isRequired,

  /**
   * button text for the create key button
   */
  createButtonText: _propTypes.default.string,

  /**
   * modal header for the create a key screen
   */
  createHeader: _propTypes.default.string,

  /**
   * an array that contains the custom step content and if the step has passed validation
   */
  customSteps: _propTypes.default.arrayOf(_propTypes.default.shape({
    valid: _propTypes.default.bool,
    content: _propTypes.default.node
  })),

  /**
   * text fot the download message
   */
  downloadBodyText: _propTypes.default.string,

  /**
   * text for the download link
   */
  downloadLinkText: _propTypes.default.string,

  /**
   * specifies if the api key is downloadable or not
   */
  downloadable: _propTypes.default.bool,

  /**
   * specifies the filename for downloadable api keys
   */
  downloadableFileName: _propTypes.default.string,

  /**
   * specifices if an error has occured
   */
  error: _propTypes.default.bool,

  /**
   * message to display when modal in an error state
   */
  errorMessage: _propTypes.default.string,

  /**
   * specifies if the api key creation is loading
   */
  loading: _propTypes.default.bool,

  /**
   * loading message for when the api key is loading
   */
  loadingMessage: _propTypes.default.string,

  /**
   * Label for modal
   */
  modalLabel: _propTypes.default.string,

  /**
   * helper text for name input
   */
  nameHelperText: _propTypes.default.string,

  /**
   * id for name input
   */
  nameInputId: _propTypes.default.string,

  /**
   * label for name input
   */
  nameLabel: _propTypes.default.string,

  /**
   * placeholder for name input
   */
  namePlaceholder: _propTypes.default.string,

  /**
   * specifices if a name is required. If you are using custom steps DO NOT use this for validation.
   * use the `valid` prop in the `customSteps` prop array for validation. see `customSteps` for additional information.
   */
  nameRequired: _propTypes.default.bool,

  /**
   * Specifies text for next step button
   */
  nextStepButtonText: _propTypes.default.string,

  /**
   * function to close the modal
   */
  onClose: _propTypes.default.func,

  /**
   * function that is called to create the api key
   */
  onRequestSubmit: _propTypes.default.func,

  /**
   * specifies if the modal is open or not
   */
  open: _propTypes.default.bool,

  /**
   * Specifices text for previous step button
   */
  previousStepButtonText: _propTypes.default.string,

  /**
   * text for the close button
   */
  secondaryButtonText: _propTypes.default.string,

  /**
   * Modal header for individual steps
   */
  stepHeaders: _propTypes.default.arrayOf(_propTypes.default.string),

  /**
   * content for when an api key is created successfully
   */
  successBody: _propTypes.default.node.isRequired,

  /**
   * modal header for a successful api key creation
   */
  successHeader: _propTypes.default.string.isRequired
};
APIKeyModal.defaultProps = {
  apiKeyVisibility: false,
  customSteps: [],
  downloadable: false,
  loading: false,
  nameRequired: false,
  open: false,
  stepHeaders: []
};
APIKeyModal.displayName = componentName;