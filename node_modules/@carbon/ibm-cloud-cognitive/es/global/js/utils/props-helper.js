import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

//
// Copyright IBM Corp. 2020, 2021
//
// This source code is licensed under the Apache-2.0 license found in the
// LICENSE file in the root directory of this source tree.
//
import React from 'react';
import PropTypes from 'prop-types';
import unwrapIfFragment from './unwrap-if-fragment';
import pconsole from './pconsole'; // helper functions for component props

/**
 * Prepare a set of props, or prop types or default props, merging values
 * from one or more sets and optionally blocking keys which should not be
 * passed. Returns the prepared set of props. Does not modify any of the
 * objects passed.
 *
 * @param {{} | '' | ['']} values One or more sets of keys and values to be
 * merged, or names of keys to be blocked. Each parameter that is an object is
 * treated as keys and values to be merged, and each parameter that is a string
 * or an array of strings is treated as keys to be blocked.
 *
 * Examples:
 *   const props = { a: 3, c: 4, d: 5 };
 *
 *   * prepareProps(props) -> { a: 3, c: 4, d: 5 }
 *   * prepareProps(props, 'c') -> { a: 3, d: 5 }
 *   * prepareProps(props, ['a', 'c', 'e']) -> { d: 5 }
 *
 *   * prepareProps({ a: 1, b: 2 }, props) -> { a: 3, b: 2, c: 4, d: 5 }
 *   * prepareProps({ a: 1, b: 2 }, props, ['a', 'c']) -> { b: 2, d: 5 }
 *
 *   * prepareProps(props, { c: 6 }) -> { a: 3, c: 6, d: 5 }
 *   * prepareProps(props, 'a', { c: 6 }) -> { c: 6, d: 5 }
 */

export var prepareProps = function prepareProps() {
  // Convert any string or array arg into an object with nulls as values
  var toNulls = function toNulls(arg) {
    return typeof arg === 'string' ? _defineProperty({}, arg, null) : Array.isArray(arg) ? Object.fromEntries(arg.map(function (key) {
      return [key, null];
    })) : arg;
  }; // Merge all the args from left to right


  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }

  var merged = Object.assign.apply(Object, [{}].concat(_toConsumableArray(values.map(toNulls)))); // Now strip any keys whose final value is null

  return Object.entries(merged).reduce(function (result, _ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        key = _ref3[0],
        value = _ref3[1];

    if (value !== null) {
      result[key] = value;
    }

    return result;
  }, {});
}; // A simple wrapper for a prop-types checker that issues a warning message if
// the value being validated is not null/undefined.

var deprecatePropInner = function deprecatePropInner(message, validator, info) {
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    // args = [props, propName, componentName, location, propFullName, ...]
    args[0][args[1]] && pconsole.warn(message(args[3], args[4] || args[1], args[2], info));
    return validator.apply(void 0, args);
  };
};
/**
 * A prop-types type checker that marks a particular usage of a prop as
 * deprecated. This can be used to deprecate an option in a oneOfType checker,
 * and the deprecated option(s) should be listed last so that the deprecation
 * message is only reported if none of the other type options is matched.
 * @param {} validator The prop-types validator for the prop usage as it should
 * be if it weren't deprecated. If this validator produces type checking
 * errors they will be reported as usual.
 * @param {*} additionalInfo One or more sentences to be appended to the
 * deprecation message to explain why the prop usage is deprecated and/or what
 * should be used instead.
 * @returns Any type checking error reported by the validator, or null.
 */


export var deprecatePropUsage = deprecatePropInner.bind(undefined, function (location, propName, componentName, info) {
  return "The usage of the ".concat(location, " `").concat(propName, "` of `").concat(componentName, "` has been changed and support for the old usage will soon be removed. ").concat(info);
});
/**
 * A prop-types type checker that marks a prop as deprecated.
 * @param {} validator The prop-types validator for the prop as it should be
 * used if it weren't deprecated. If this validator produces type checking
 * errors they will be reported as usual.
 * @param {*} additionalInfo One or more sentences to be appended to the
 * deprecation message to explain why the prop is deprecated and/or what should
 * be used instead.
 * @returns Any type checking error reported by the validator, or null.
 */

export var deprecateProp = deprecatePropInner.bind(undefined, function (location, propName, componentName, info) {
  return "The ".concat(location, " `").concat(propName, "` of `").concat(componentName, "` has been deprecated and will soon be removed. ").concat(info);
});
/**
 * Takes items as fragment, node or array
 * @param {node || array} items - which may have shape to extract
 * @returns Array of items
 */

export var extractShapesArray = function extractShapesArray(items) {
  var _items$, _items$2;

  // unwrap if items or the first index looks like a React element or fragment
  if (items && (items !== null && items !== void 0 && (_items$ = items[0]) !== null && _items$ !== void 0 && _items$.props || (items === null || items === void 0 ? void 0 : (_items$2 = items[0]) === null || _items$2 === void 0 ? void 0 : _items$2.type) === React.Fragment || items.type === React.Fragment)) {
    return unwrapIfFragment(items).map(function (item) {
      return _objectSpread({}, item.props);
    });
  }

  return Array.isArray(items) ? items : [];
};
/**
 * A prop-types validation function that takes an array of type checkers and
 * requires prop values to satisfy all of the type checkers. This can be useful
 * to combine custom validation functions with regular prop types, or for
 * combining inherited prop-types from another component with tighter
 * requirements.
 *
 * Examples:
 *
 * MyComponent.propTypes = {
 *
 *   foo: allPropTypes([
 *     customValidationFunction,
 *     PropTypes.arrayOf(
 *       PropTypes.shape({
 *         text: PropType.string
 *       })
 *     )
 *   ]),
 *
 *   kind: allPropTypes([
 *     Button.propTypes.kind,
 *     PropTypes.oneOf('primary', 'secondary')
 *   ]),
 *
 * }
 */

export var allPropTypes = pconsole.shimIfProduction(function (arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    pconsole.error('Warning: Invalid argument supplied to allPropTypes, expected an instance of array.');
    return pconsole.noop;
  }

  for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
    if (typeof arrayOfTypeCheckers[i] !== 'function') {
      pconsole.error("Invalid argument supplied to allPropTypes. Expected an array of check functions, but received ".concat(arrayOfTypeCheckers[i], " at index ").concat(i, "."));
      return pconsole.noop;
    }
  }

  var checkType = function checkType() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var error = null;
    arrayOfTypeCheckers.some(function (checker) {
      return error = checker.apply(void 0, args);
    });
    return error;
  };

  checkType.isRequired = function (props, propName, comp, loc, propFullName, secret) {
    var prop = propFullName || propName;
    return props[prop] == null ? new Error("The ".concat(loc, " `").concat(prop, "` is marked as required in `").concat(comp || '<<anonymous>>', "`, but its value is `").concat(props[prop] === null ? 'null' : 'undefined', "`.")) : checkType(props, prop, comp, loc, propFullName, secret);
  };

  return checkType;
});
/**
 * A prop-types validation function that takes a type checkers and a condition
 * function and invokes either the type checker or the isRequired variant of
 * the type checker according to whether the condition function returns false
 * or true when called with the full set of props. This can be useful to make
 * a prop conditionally required. The function also has a decorate function
 * which can be used to add isRequiredIf to any existing type which already has
 * an isRequired variant, and this is automatically applied to the simple type
 * checkers in PropTypes when this props-helper module is imported. The second
 * example produces better results with DocGen and Storybook.
 *
 * Examples:
 *
 * MyComponent1.propTypes = {
 *   showFoo: PropTypes.bool,
 *   fooLabel: isRequiredIf(PropTypes.string, ({ showFoo }) => showFoo),
 * }
 *
 * MyComponent2.propTypes = {
 *   showBar: PropTypes.bool,
 *   barLabel: PropTypes.string.isRequired.if(({ showBar }) => showBar),
 * }
 *
 */

export var isRequiredIf = function isRequiredIf(checker, conditionFn) {
  return function (props, propName, componentName, location, propFullName, secret) {
    return (conditionFn(props) ? checker.isRequired : checker)(props, propName, componentName, location, propFullName, secret);
  };
};

isRequiredIf.decorate = function (checker) {
  checker.isRequired.if = pconsole.isProduction ? pconsole.noop : isRequiredIf.bind(null, checker);
};

for (var checker in PropTypes) {
  if (PropTypes[checker].isRequired) {
    isRequiredIf.decorate(PropTypes[checker]);
  }
}