import _extends from "@babel/runtime/helpers/extends";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["backButtonText", "cancelButtonText", "children", "className", "description", "includeViewAllToggle", "label", "nextButtonText", "onClose", "onRequestSubmit", "open", "submitButtonText", "title", "verticalPosition", "viewAllToggleLabelText", "viewAllToggleOffLabelText", "viewAllToggleOnLabelText"];
import _regeneratorRuntime from "@babel/runtime/regenerator";

/**
 * Copyright IBM Corp. 2021, 2021
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import React, { forwardRef, useCallback, useEffect, useState, useRef } from 'react';
import PropTypes from 'prop-types';
import { ProgressIndicator, ProgressStep, Toggle } from 'carbon-components-react';
import { SideNav, SideNavItems, SideNavLink } from 'carbon-components-react/lib/components/UIShell';
import cx from 'classnames';
import wrapFocus from '../../global/js/utils/wrapFocus';
import { TearsheetShell } from '../Tearsheet/TearsheetShell';
import { pkg } from '../../settings';
import { CREATE_TEARSHEET_SECTION, CREATE_TEARSHEET_STEP } from './constants';
var componentName = 'CreateTearsheet';
var blockClass = "".concat(pkg.prefix, "--tearsheet-create");

var usePreviousValue = function usePreviousValue(value) {
  var ref = useRef();
  useEffect(function () {
    ref.current = value;
  });
  return ref.current;
};

export var CreateTearsheet = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var backButtonText = _ref.backButtonText,
      cancelButtonText = _ref.cancelButtonText,
      children = _ref.children,
      className = _ref.className,
      description = _ref.description,
      includeViewAllToggle = _ref.includeViewAllToggle,
      label = _ref.label,
      nextButtonText = _ref.nextButtonText,
      onClose = _ref.onClose,
      onRequestSubmit = _ref.onRequestSubmit,
      open = _ref.open,
      submitButtonText = _ref.submitButtonText,
      title = _ref.title,
      verticalPosition = _ref.verticalPosition,
      viewAllToggleLabelText = _ref.viewAllToggleLabelText,
      viewAllToggleOffLabelText = _ref.viewAllToggleOffLabelText,
      viewAllToggleOnLabelText = _ref.viewAllToggleOnLabelText,
      rest = _objectWithoutProperties(_ref, _excluded);

  var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      createTearsheetActions = _useState2[0],
      setCreateTearsheetActions = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      shouldViewAll = _useState4[0],
      setShouldViewAll = _useState4[1];

  var _useState5 = useState(0),
      _useState6 = _slicedToArray(_useState5, 2),
      currentStep = _useState6[0],
      setCurrentStep = _useState6[1];

  var _useState7 = useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      isSubmitting = _useState8[0],
      setIsSubmitting = _useState8[1];

  var _useState9 = useState(0),
      _useState10 = _slicedToArray(_useState9, 2),
      activeSectionIndex = _useState10[0],
      setActiveSectionIndex = _useState10[1];

  var previousState = usePreviousValue({
    currentStep: currentStep,
    open: open
  }); // set current step to 1 upon tearsheet opening, in order
  // to get the auto focus on the first step.

  useEffect(function () {
    if (!(previousState !== null && previousState !== void 0 && previousState.open) && open) {
      setCurrentStep(1);
    }
  }, [open, previousState]); // Log a warning to the console in the event a create tearsheet is used with only one step

  useEffect(function () {
    var createSteps = getTearsheetSteps();
    var total = createSteps.length;

    if (total === 1) {
      console.warn("".concat(componentName, ": CreateTearsheets with one step are not permitted. If you require only one step, please use either the narrow tearsheet, CreateSidePanel, or CreateModal components."));
    }
  }, [getTearsheetSteps]); // useEffect to handle multi step logic

  useEffect(function () {
    var _getTearsheetSteps;

    var onUnmount = function onUnmount() {
      setCurrentStep(0);
      setIsSubmitting(false);
      setShouldViewAll(false);
      onClose();
    };

    var handleOnRequestSubmit = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return onRequestSubmit();

              case 3:
                onUnmount();
                _context.next = 10;
                break;

              case 6:
                _context.prev = 6;
                _context.t0 = _context["catch"](0);
                setIsSubmitting(false);
                console.warn("".concat(componentName, " submit error: ").concat(_context.t0));

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 6]]);
      }));

      return function handleOnRequestSubmit() {
        return _ref2.apply(this, arguments);
      };
    }();

    var isSubmitDisabled = function isSubmitDisabled() {
      var step = 0;
      var submitDisabled = false;
      var tearsheetSteps = getTearsheetSteps();
      tearsheetSteps.forEach(function (child) {
        step++;

        if (currentStep === step) {
          submitDisabled = child.props.disableSubmit;
        }
      });
      return submitDisabled;
    };

    var handleNext = /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var createSteps;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                setIsSubmitting(true);
                createSteps = getTearsheetSteps();

                if (!createSteps[currentStep - 1].props.onNext) {
                  _context2.next = 15;
                  break;
                }

                _context2.prev = 3;
                _context2.next = 6;
                return createSteps[currentStep - 1].props.onNext();

              case 6:
                continueToNextStep();
                _context2.next = 13;
                break;

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](3);
                setIsSubmitting(false);
                console.warn("".concat(componentName, " onNext error: ").concat(_context2.t0));

              case 13:
                _context2.next = 16;
                break;

              case 15:
                continueToNextStep();

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[3, 9]]);
      }));

      return function handleNext() {
        return _ref3.apply(this, arguments);
      };
    }();

    var handleSubmit = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var createSteps;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                setIsSubmitting(true);
                createSteps = getTearsheetSteps(); // last step should have onNext as well

                if (!createSteps[currentStep - 1].props.onNext) {
                  _context3.next = 16;
                  break;
                }

                _context3.prev = 3;
                _context3.next = 6;
                return createSteps[currentStep - 1].props.onNext();

              case 6:
                _context3.next = 8;
                return handleOnRequestSubmit();

              case 8:
                _context3.next = 14;
                break;

              case 10:
                _context3.prev = 10;
                _context3.t0 = _context3["catch"](3);
                setIsSubmitting(false);
                console.warn("".concat(componentName, " onNext error: ").concat(_context3.t0));

              case 14:
                _context3.next = 18;
                break;

              case 16:
                _context3.next = 18;
                return handleOnRequestSubmit();

              case 18:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[3, 10]]);
      }));

      return function handleSubmit() {
        return _ref4.apply(this, arguments);
      };
    }();

    if ((_getTearsheetSteps = getTearsheetSteps()) !== null && _getTearsheetSteps !== void 0 && _getTearsheetSteps.length) {
      var createSteps = getTearsheetSteps();
      var total = createSteps.length;
      var buttons = [];

      if (total > 1 && !shouldViewAll) {
        buttons.push({
          label: backButtonText,
          onClick: function onClick() {
            return setCurrentStep(function (prev) {
              return prev - 1;
            });
          },
          kind: 'secondary',
          disabled: currentStep === 1
        });
      }

      buttons.push({
        label: cancelButtonText,
        onClick: onUnmount,
        kind: 'ghost'
      });
      buttons.push({
        label: shouldViewAll ? submitButtonText : currentStep < total ? nextButtonText : submitButtonText,
        onClick: shouldViewAll ? handleSubmit : currentStep < total ? handleNext : handleSubmit,
        disabled: isSubmitDisabled(),
        kind: 'primary',
        loading: isSubmitting,
        className: "".concat(blockClass, "__create-button")
      });
      setCreateTearsheetActions(buttons);
    }
  }, [getTearsheetSteps, children, backButtonText, cancelButtonText, currentStep, onClose, nextButtonText, submitButtonText, onRequestSubmit, isSubmitting, shouldViewAll]);

  var continueToNextStep = function continueToNextStep() {
    setIsSubmitting(false);
    setCurrentStep(function (prev) {
      return prev + 1;
    });
  }; // returns an array of tearsheet steps


  var getTearsheetSteps = useCallback(function () {
    var steps = [];
    var childrenArray = Array.isArray(children) ? children : [children];
    childrenArray.forEach(function (child) {
      if (isTearsheetStep(child)) {
        steps.push(child);
      }
    });
    return steps;
  }, [children]); // check if child is a tearsheet step component

  var isTearsheetStep = function isTearsheetStep(child) {
    if (child && child.props && child.props.type === CREATE_TEARSHEET_STEP) {
      return true;
    }

    return false;
  }; // check if child is a tearsheet section component


  var isTearsheetSection = function isTearsheetSection(child) {
    if (child && child.props && child.props.type === CREATE_TEARSHEET_SECTION) {
      return true;
    }

    return false;
  }; // renders the step progression components in the left influencer area


  var renderProgressSteps = function renderProgressSteps(childrenElements) {
    var childrenArray = Array.isArray(childrenElements) ? childrenElements : [childrenElements];
    var stepChildren = childrenArray.filter(function (child) {
      return isTearsheetStep(child);
    });
    var sectionChildElements = [];
    stepChildren.forEach(function (child) {
      // we have received an array of children, lets check to see that each child is
      // a CreateTearsheetSection component before adding it to sectionChildElements
      if (shouldViewAll && child.props.children.length) {
        child.props.children.forEach(function (stepChild) {
          if (isTearsheetSection(stepChild)) {
            sectionChildElements.push(stepChild);
          }
        });
      } // we have received a single child element, lets check to see that it is
      // a CreateTearsheetSection component before adding it to sectionChildElements


      if (shouldViewAll && typeof child.props.children !== 'undefined' && !child.props.children.length) {
        if (isTearsheetSection(child.props.children)) {
          sectionChildElements.push(child.props.children);
        }
      }
    });

    if (shouldViewAll) {
      return /*#__PURE__*/React.createElement("div", {
        className: "".concat(blockClass, "__left-nav")
      }, /*#__PURE__*/React.createElement(SideNav, {
        expanded: true,
        isFixedNav: true
      }, /*#__PURE__*/React.createElement(SideNavItems, null, (sectionChildElements === null || sectionChildElements === void 0 ? void 0 : sectionChildElements.length) && sectionChildElements.map(function (sectionChild, sectionIndex) {
        return /*#__PURE__*/React.createElement(SideNavLink, {
          href: "javascript:void(0)",
          key: sectionIndex,
          isActive: activeSectionIndex === sectionIndex,
          onClick: function onClick() {
            setActiveSectionIndex(sectionIndex);

            if (sectionChild.props.id) {
              var scrollTarget = document.querySelector("#".concat(sectionChild.props.id));
              var scrollContainer = document.querySelector(".".concat(pkg.prefix, "--tearsheet__main"));
              scrollContainer.scrollTo({
                top: scrollTarget.offsetTop,
                behavior: 'smooth'
              });
            } else {
              console.warn("".concat(componentName, ": CreateTearsheetSection is missing a required prop of 'id'"));
            }
          }
        }, sectionChild.props.title);
      }))));
    }

    return /*#__PURE__*/React.createElement("div", {
      className: "".concat(blockClass, "__left-nav")
    }, /*#__PURE__*/React.createElement(ProgressIndicator, {
      currentIndex: currentStep - 1,
      spaceEqually: true,
      vertical: true,
      className: "".concat(blockClass, "__progress-indicator")
    }, stepChildren.map(function (child, stepIndex) {
      return /*#__PURE__*/React.createElement(ProgressStep, {
        label: child.props.title,
        key: stepIndex
      });
    })));
  }; // renders all children (CreateTearsheetSteps and regular children elements)


  var renderChildren = function renderChildren(childrenElements) {
    var step = 0;
    var childrenArray = Array.isArray(childrenElements) ? childrenElements : [childrenElements];
    return /*#__PURE__*/React.createElement(React.Fragment, null, ' ', childrenArray.map(function (child, stepIndex) {
      var _cx;

      if (!isTearsheetStep(child)) {
        return child;
      }

      step++;
      return /*#__PURE__*/React.cloneElement(child, {
        className: cx(child.props.className, (_cx = {}, _defineProperty(_cx, "".concat(blockClass, "__step--hidden-step"), !shouldViewAll && currentStep !== step), _defineProperty(_cx, "".concat(blockClass, "__step--visible-step"), currentStep === step), _defineProperty(_cx, "".concat(blockClass, "__step--first-panel-step"), !(previousState !== null && previousState !== void 0 && previousState.open) && open && (previousState === null || previousState === void 0 ? void 0 : previousState.currentStep) === 0 && stepIndex === 0), _cx)),
        key: "key_".concat(stepIndex)
      }, /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("p", {
        className: "".concat(blockClass, "__step--heading")
      }, renderStepTitle(stepIndex)), renderStepChildren(child.props.children)));
    }));
  };

  var renderStepChildren = function renderStepChildren(stepChildren) {
    var childrenArray = Array.isArray(stepChildren) ? stepChildren : [stepChildren];
    return /*#__PURE__*/React.createElement(React.Fragment, null, childrenArray.map(function (child, index) {
      var _cx2;

      if (!isTearsheetSection(child)) {
        return child;
      }

      return /*#__PURE__*/React.cloneElement(child, {
        className: cx(child.props.className, (_cx2 = {}, _defineProperty(_cx2, "".concat(blockClass, "__step--hidden-section"), child.props.viewAllOnly && !shouldViewAll), _defineProperty(_cx2, "".concat(blockClass, "__step--visible-section"), !child.props.viewAllOnly || child.props.viewAllOnly && shouldViewAll), _cx2)),
        key: "key_".concat(index)
      });
    }));
  }; // renders the individual step title


  var renderStepTitle = function renderStepTitle(stepIndex) {
    var _tearsheetSteps$stepI;

    var tearsheetSteps = getTearsheetSteps();
    var stepTitle = tearsheetSteps && ((_tearsheetSteps$stepI = tearsheetSteps[stepIndex]) === null || _tearsheetSteps$stepI === void 0 ? void 0 : _tearsheetSteps$stepI.props.title) || null;
    return stepTitle;
  }; // set initial focus when the step changes, if there is not an input to focus
  // the next/create button receives focus


  useEffect(function () {
    if (open && (previousState === null || previousState === void 0 ? void 0 : previousState.currentStep) !== currentStep && currentStep > 0) {
      var visibleStepInnerContent = document.querySelector(".".concat(blockClass, "__step.").concat(blockClass, "__step--visible-step"));
      var tearsheetSteps = getTearsheetSteps();
      var focusableStepElements = tearsheetSteps && tearsheetSteps.length && getFocusableElements(visibleStepInnerContent);

      if (focusableStepElements && focusableStepElements.length) {
        focusableStepElements[0].focus();
      } else {
        var nextButton = document.querySelector(".".concat(blockClass, "__create-button"));
        nextButton === null || nextButton === void 0 ? void 0 : nextButton.focus();
      }
    }
  }, [open, currentStep, getTearsheetSteps, previousState]); // returns an array of focusable elements, for use in auto focusing the first input on a step

  var getFocusableElements = function getFocusableElements(element) {
    return _toConsumableArray(element.querySelectorAll('a, button, input, textarea, select, details,[tabindex]:not([tabindex="-1"])')).filter(function (e) {
      return !e.hasAttribute('disabled');
    });
  }; // adds focus trap functionality

  /* istanbul ignore next */


  var handleBlur = function handleBlur(_ref5) {
    var oldActiveNode = _ref5.target,
        currentActiveNode = _ref5.relatedTarget;
    var visibleStepInnerContent = document.querySelector(".".concat(pkg.prefix, "--tearsheet__body"));
    var visibleStepStartMarker;
    var visibleStepEndMarker;

    if (open && visibleStepInnerContent) {
      wrapFocus({
        bodyNode: visibleStepInnerContent,
        visibleStepStartMarker: visibleStepStartMarker,
        visibleStepEndMarker: visibleStepEndMarker,
        currentActiveNode: currentActiveNode,
        oldActiveNode: oldActiveNode
      });
    }
  };

  var handleViewAllToggle = function handleViewAllToggle(toggleState) {
    setShouldViewAll(toggleState);
    setActiveSectionIndex(0); // scroll to top of tearsheet page upon toggling view all option

    if (toggleState) {
      var createTearsheetContainer = document.querySelector(".".concat(blockClass));
      createTearsheetContainer.scrollTop = 0;
    }
  };

  var renderViewAllToggle = function renderViewAllToggle() {
    return /*#__PURE__*/React.createElement(Toggle, {
      id: "".concat(blockClass, "__view-all-toggle"),
      toggled: shouldViewAll,
      labelText: viewAllToggleLabelText,
      labelA: viewAllToggleOffLabelText,
      labelB: viewAllToggleOnLabelText,
      onToggle: function onToggle(value) {
        return handleViewAllToggle(value);
      },
      className: "".concat(blockClass, "__view-all-toggle")
    });
  };

  return /*#__PURE__*/React.createElement(TearsheetShell, _extends({}, rest, {
    actions: createTearsheetActions,
    className: cx(blockClass, className),
    closeIconDescription: 'Close icon',
    description: description,
    hasCloseIcon: false,
    influencer: /*#__PURE__*/React.createElement(React.Fragment, null, renderProgressSteps(children), includeViewAllToggle && renderViewAllToggle()),
    influencerPosition: "left",
    influencerWidth: "narrow",
    label: label,
    onClose: onClose,
    open: open,
    size: "wide",
    title: title,
    verticalPosition: verticalPosition,
    ref: ref
  }), /*#__PURE__*/React.createElement("div", {
    className: "".concat(blockClass, "__multi-step-panel-content"),
    onBlur: handleBlur
  }, renderChildren(children)));
}); // Return a placeholder if not released and not enabled by feature flag

CreateTearsheet = pkg.checkComponentEnabled(CreateTearsheet, componentName); // The display name of the component, used by React. Note that displayName
// is used in preference to relying on function.name.

CreateTearsheet.displayName = componentName; // Note that the descriptions here should be kept in sync with those for the
// corresponding props for TearsheetNarrow and TearsheetShell components.

CreateTearsheet.propTypes = {
  /**
   * The back button text
   */
  backButtonText: PropTypes.string.isRequired,

  /**
   * The cancel button text
   */
  cancelButtonText: PropTypes.string.isRequired,

  /**
   * The main content of the tearsheet
   */
  children: PropTypes.node,

  /**
   * An optional class or classes to be added to the outermost element.
   */
  className: PropTypes.string,

  /**
   * A description of the flow, displayed in the header area of the tearsheet.
   */
  description: PropTypes.node,

  /**
   * Used to optionally include view all toggle
   */
  includeViewAllToggle: PropTypes.bool,

  /**
   * A label for the tearsheet, displayed in the header area of the tearsheet
   * to maintain context for the tearsheet (e.g. as the title changes from page
   * to page of a multi-page task).
   */
  label: PropTypes.node,

  /**
   * The next button text
   */
  nextButtonText: PropTypes.string.isRequired,

  /**
   * An optional handler that is called when the user closes the tearsheet (by
   * clicking the close button, if enabled, or clicking outside, if enabled).
   * Returning `false` here prevents the modal from closing.
   */
  onClose: PropTypes.func,

  /**
   * Specify a handler for submitting the multi step tearsheet (final step).
   * This function can _optionally_ return a promise that is either resolved or rejected and the CreateTearsheet will handle the submitting state of the create button.
   */
  onRequestSubmit: PropTypes.func.isRequired,

  /**
   * Specifies whether the tearsheet is currently open.
   */
  open: PropTypes.bool,

  /**
   * The submit button text
   */
  submitButtonText: PropTypes.string.isRequired,

  /**
   * The main title of the tearsheet, displayed in the header area.
   */
  title: PropTypes.node,

  /**
   * The position of the top of tearsheet in the viewport. The 'normal'
   * position (the default) is a short distance down from the top of the
   * viewport, leaving room at the top for a global header bar to show through
   * from below. The 'lower' position provides a little extra room at the top
   * to allow an action bar navigation or breadcrumbs to also show through.
   */
  verticalPosition: PropTypes.oneOf(['normal', 'lower']),

  /**
   * Sets the label text for the view all toggle component
   */
  viewAllToggleLabelText: PropTypes.string,

  /**
   * Sets the label text for the view all toggle `off` text
   */
  viewAllToggleOffLabelText: PropTypes.string,

  /**
   * Sets the label text for the view all toggle `on` text
   */
  viewAllToggleOnLabelText: PropTypes.string
}; // Default values for component props. Default values are not required for
// props that are required, nor for props where the component can apply
// 'undefined' values reasonably. Default values should be provided when the
// component needs to make a choice or assumption when a prop is not supplied.

CreateTearsheet.defaultProps = {
  verticalPosition: 'normal'
};